---
title: "Workflow for bulk RNA-seq analysis"
date: "04-12-2024"
editor_options: 
  chunk_output_type: console
output: 
  html_document:
    toc: true
    theme: cerulean
    toc_float: true
---




# **1. Data preparation**


```{r eval=FALSE, echo=TRUE}

# Install libraries of interest
install.packages("tidyverse")
install.packages("BiocManager")
BiocManager::install("biomaRt")
BiocManager::install("scater")
install.packages("devtools")
devtools::install_github("sysbio-curie/rRoma")
devtools::install_github("husson/FactoMineR")
BiocManager::install("OmnipathR")
BiocManager::install("decoupleR")
BiocManager::install("ComplexHeatmap")
BiocManager::install("edgeR")
BiocManager::install("DESeq2")
install.packages("patchwork")
install.packages("factoextra")



# Load the libraries of interest
library(tidyverse)
library(rRoma)
library(OmnipathR)
library(decoupleR)
library(patchwork)
library(ComplexHeatmap)
library(edgeR)
library(DESeq2)
library(factoextra)
library(FactoMineR)
```




```{r eval=FALSE, echo=TRUE}

## I come up with RNA sequencing data (in vitro) at different timepoints:


### First, I export the count matrix (from the preprocessing results) and my sample plan, and prepare them for further analysis.


#### How do I proceed ?

# Load sample plan
sample_plan_in_vitro_df <- readRDS("~/MODICED_link/Bulk_RNA_in_vitro/preprocessing_in_vitro_RNA/sample_plan_in_vitro_for_analysis.rds") %>% as.data.frame()
attach(sample_plan_in_vitro_df)


# We have three drugs: Mitoxantrone (MTX), Oxaliplatin (OXA), Cisplatin (CIS) and Control (for untreated).
colnames(sample_plan_in_vitro_df) <- c("Sample_ID", "Sample_Name", "Path_to_R1")
sample_plan_in_vitro_df[grepl("MTX", sample_plan_in_vitro_df$Sample_Name), "Treatment"] <- "MTX"
sample_plan_in_vitro_df[grepl("OXA", sample_plan_in_vitro_df$Sample_Name), "Treatment"] <- "OXA"
sample_plan_in_vitro_df[grepl("CIS", sample_plan_in_vitro_df$Sample_Name), "Treatment"] <- "CIS"
sample_plan_in_vitro_df[grepl("Control", sample_plan_in_vitro_df$Sample_Name), "Treatment"] <- "Control"


# And 5 timepoints: 3h, 6h, 12h, 18h, 24h.
sample_plan_in_vitro_df[grepl("3h", sample_plan_in_vitro_df$Sample_Name), "Time_Point"] <- "3h"
sample_plan_in_vitro_df[grepl("6h", sample_plan_in_vitro_df$Sample_Name), "Time_Point"] <- "6h"
sample_plan_in_vitro_df[grepl("12h", sample_plan_in_vitro_df$Sample_Name), "Time_Point"] <- "12h"
sample_plan_in_vitro_df[grepl("18h", sample_plan_in_vitro_df$Sample_Name), "Time_Point"] <- "18h"
sample_plan_in_vitro_df[grepl("24h", sample_plan_in_vitro_df$Sample_Name), "Time_Point"] <- "24h"


# Concatenate treatment and timepoint columns.
sample_plan_in_vitro_df <- sample_plan_in_vitro_df %>% tidyr::unite(col = "Treatment_hour", Treatment, Time_Point, remove = FALSE, sep = "_") %>% relocate(Treatment_hour, .after = Time_Point)
rownames(sample_plan_in_vitro_df) <- sample_plan_in_vitro_df$Sample_Name



# Load gtf for mouse to retrieve gene_type
gtf <- import("/data/annotations/pipelines/Mouse/mm10/gtf/gencode.vM22.annotation.gtf")
gtf_annot <- gtf %>% as_tibble() %>% filter(type == "gene") %>%  mutate(gene_id = str_remove(gene_id, "\\..*"))


# Load annotation table from preprocessing results and add gene_type to it.
annot_gene_mod_2 <- read.csv("/data/users/tlassale/MODICED_link/Bulk_RNA_in_vitro/preprocessing_in_vitro_RNA/results_pipeline/counts/tableannot.csv") %>% dplyr::select(gene_id, gene_name) %>% full_join(gtf_annot[, c("gene_id","gene_type")], by="gene_id")

# Load count matrix
counts_in_vitro_df <- read_delim("/data/users/tlassale/MODICED_link/Bulk_RNA_in_vitro/preprocessing_in_vitro_RNA/results_pipeline/counts/tablecounts_raw_2.csv")

# Add gene symbol + gene_type to the the count matrix.
counts_in_vitro_df <- counts_in_vitro_df %>% 
                 dplyr::rename("gene_id" = "...1") %>% 
                 inner_join(., annot_gene_mod_2, by = "gene_id") %>%
                 dplyr::relocate(gene_name, .after = gene_id) %>% 
                 dplyr::relocate(gene_type, .after = gene_name)
                 

# Make sure that colnames of count matrix are in the same order than rownames from sample plan.
counts_in_vitro_df <- counts_in_vitro_df[, c("gene_id", "gene_type", "gene_name", rownames(sample_plan_in_vitro_df))]

```


# **2. Unsupervised analysis (example of PCA)**



```{r eval=FALSE, echo=TRUE}

# Without prior knowldege, I want to explore my data, and see which samples are similar to each other and if there is any sample standing out from the others (i.e. outliers)


## How do I proceed ?

# for PCA
library(FactoMineR)

# for visualization
library(factoextra)

dlist <- DGEList(counts = counts_in_vitro_df %>% dplyr::select(-c(gene_id, gene_type, gene_name)), samples = sample_plan_in_vitro_df$Sample_Name, 
                 genes = counts_in_vitro_df %>% dplyr::select(gene_name))




# Create a DESeqDataSet object: What do I need to provide as input ?
# 1. count matrix.
# 2. metadata table.
# 3. design formula.

# Important point: Rownames of the metadata table have to match with columns of count matrix.

dds <- DESeqDataSetFromMatrix(countData = counts_in_vitro_df %>% dplyr::select(-c(gene_id, gene_type, gene_name)), colData = DataFrame(Treatment = sample_plan_in_vitro_df$Treatment, Time_point = factor(sample_plan_in_vitro_df$Time_Point)), design = ~ Treatment)



# Calculate normalization factors for each sample
dds <- estimateSizeFactors(dds)


# Filter out genes that contain zero counts
dds <- dds[rowSums(counts(dds)) > 0, ]


# Stabilize the variance over the mean (as variance grows with the mean).
rld <- vst(dds, blind=TRUE)

# Retrieve matrix of transformed values
vst_matrix <- assay(rld)

# Run PCA with the first 4 principal components
run_pca <- PCA(t(vst_matrix), ncp=4, graph=FALSE)

# Plot samples (colored by treatment) - PC1 and PC2 by default
fviz_pca_ind(run_pca, axis = c(1,2), label="ind", habillage = as.factor(sample_plan_mod_2$Treatment), repel=TRUE, pointsize = 3, labelsize = 3, invisible = "quali")

# Other example: plot samples (colored by treatment) - PC1 and PC3
fviz_pca_ind(run_pca, axis = c(1,3), label="ind", habillage = as.factor(sample_plan_mod_2$Treatment), repel=TRUE, pointsize = 3, labelsize = 3, invisible = "quali")

```


# **3. Differential gene expression analysis**



```{r eval=FALSE, echo=TRUE}
## DEA

# Now, I want to statistically evaluate the effect of each drug, at each timepoint.


## How do I proceed ?

library(edgeR)

# Create model matrix (explanatory variable = Treatment_hour)
dsgn <- model.matrix(~ 0 + Treatment_hour, data=dlist$samples)
colnames(dsgn) <- sub("Treatment_hour","",colnames(dsgn))


# Get the genes which are very low expressed (minimum total count in all the samples = 15)
keep <- filterByExpr(dlist$counts, dsgn)

# Filter out these genes from the count matrix
dlist_filtered <- dlist[keep,]

# Calculate normalisation factors (using trimmed mean of M-values method from edgeR)
dlist_filtered <- calcNormFactors(dlist_filtered, method="TMM")


# Make the data ready for linear modelling:
# 1. Convert raw counts into log2CPM, using normalized library size by: raw library size * scaling factor. Scaling factor is retrieved from calcNormFactors.
# 2. Estimate the mean-variance trend of the log-counts to generate a precision weight for each sample.
# 3. Retrieve gene symbols from voom object, and put them as rownames.
voom <- voomWithQualityWeights(dlist_filtered, dsgn)
counts_in_vitro_normalized <- cbind(voom$E, voom$genes)
rownames(counts_for_gautier) <- make.names(counts_for_gautier$genes, unique=TRUE)
counts_for_gautier <- counts_for_gautier %>% dplyr::select(-"genes")


# Fit a linear model for each gene using weighted least squares.
fit_dea <- lmFit(counts_for_gautier, dsgn)


# Prepare contrasts (i.e. sample groups) to compare for differential analysis 

# At a given timepoint: 3h.
# Three drugs: MTX (for Mitoxantrone), CIS (for Cisplatin), CIS (for Cisplatin).
contrast_for_dea_3h <- makeContrasts(MTX_3h_vs_Control_3h = MTX_3h - Control_3h, CIS_3h_vs_Control_3h = CIS_3h - Control_3h, Cis_vs_Control_3h = CIS_3h - Control_3h, levels=dsgn)


# Estimate contrast for each gene 
fit_contrast_3h <- contrasts.fit(fit_dea, contrast_for_dea_3h)



# Empirical Bayes smoothing of standard errors (i.e. shrinks standard errors that are much larger or smaller than those from other genes towards the average standard error)
fit_contrast_3h <- eBayes(fit_contrast_3h)



# Get results from DEA

# In the function, I retrieve:
# 1. The top table (with all the genes tested for differential expression).
# 2. The up-regulated genes.
# 3. The down-regulated genes.
# 4. The up-regulated concatenated with the down-regulated genes.
# 5. Volcano plot.

get_results_dea <- function(fit_contrast, coef_interest, all_genes_filename, up_reg_genes_filename, down_reg_genes_filename, all_diff_genes_concat_filename, label, volcano_plot_filename, volcano_plot_widget_filename){
  
  
  
  # Top table with all the genes (+ Save it)
  all_genes <- topTable(fit_contrast, sort.by= "P", adjust.method = "BH", number = Inf, coef = coef_interest) %>% rownames_to_column("gene_name")
 

  write.csv(all_genes, all_genes_filename, col.names = TRUE, row.names = FALSE)

  
  # Get up-reg genes
  up_reg_genes <- all_genes %>% filter(adj.P.Val < 0.05 & logFC > 0) %>% dplyr::arrange(adj.P.Val) %>% 
    dplyr::mutate(group = "up")
  
  write.csv(up_reg_genes, up_reg_genes_filename, col.names = TRUE, row.names = FALSE)
  
  
  # Get down-reg genes
  down_reg_genes <- all_genes %>% filter(adj.P.Val < 0.05 & logFC < 0) %>% dplyr::arrange(adj.P.Val) %>% 
    dplyr::mutate(group = "down")
  
  write.csv(down_reg_genes, down_reg_genes_filename, col.names = TRUE, row.names = FALSE)
  
  
  
  # Concatenate up and down-reg genes (concatenated)
  all_diff_genes_concat <- rbind(up_reg_genes, down_reg_genes) 
  write.csv(all_diff_genes_concat, all_diff_genes_concat_filename, col.names = TRUE, row.names = FALSE)
  
  
  
  # Volcano Plot - Colored by logFC/adj p-value 
  volcano_plot <- all_genes %>%  
    ggplot(aes(x=logFC, y=-log10(adj.P.Val), label=gene_name)) +
    geom_point(data = filter(all_genes_Gautier, logFC > 1 & adj.P.Val < 0.05), color="red", size=1.5) +
    geom_point(data = filter(all_genes_Gautier, logFC < 1 & adj.P.Val < 0.05), color="blue", size=1.5) +
    geom_point(data = filter(all_genes_Gautier, adj.P.Val < 0.05 & (logFC > 0 & logFC < 1)), color="orange", size=1.5) +
    geom_point(data = filter(all_genes_Gautier, adj.P.Val < 0.05 & (logFC < 0 & logFC >  -1)), color="lightblue", size=1.5) +
    geom_point(data = filter(all_genes_Gautier, adj.P.Val >= 0.05 & (logFC > -1 & logFC < 1)), color="darkgrey", size=1.5) +
    ggrepel::geom_label_repel(data = filter(all_genes_Gautier, logFC > 1 & adj.P.Val < 0.05), aes(label = gene_name), label.size = 0.01, label.padding = 0.04, max.overlaps = Inf) +
    ggrepel::geom_label_repel(data = filter(all_genes_Gautier, logFC < -1 & adj.P.Val < 0.05), aes(label = gene_name), label.size = 0.01, label.padding = 0.04, max.overlaps = Inf) +
    geom_vline(xintercept = c(-1,1), colour = "black", linetype = "dashed") +
    geom_hline(yintercept = (-log10(0.05)), colour = "black", linetype = "dashed") +
    ylab("-log10(adj.P.value)") +
    xlab("log2(FoldChange)") +
    theme_linedraw() +
    ggtitle(label) +
    theme(plot.title=element_text(hjust=0.5, face="bold"))
  
  ggsave(volcano_plot_filename, width = 9, height = 5)
  
  
  
  # Plotly (+ Save object)
  volcano_plot_widget <- plotly::ggplotly(volcano_plot)
  htmlwidgets::saveWidget(volcano_plot_widget, volcano_plot_widget_filename)


}


# So if I want to evaluate the effect of a certain drug at a certain timepoint, such as Mitoxantrone at 3h.


## How do I proceed ?

# Call the function written above
get_results_dea(fit_contrast_3h, "MTX_3h_vs_Control_3h", "top_table_genes_MTX_3h_vs_Control_3h.csv", "up_reg_genes_MTX_3h_vs_Control_3h.csv", "down_reg_genes_MTX_3h_vs_Control_3h.csv", "up_and_down_reg_genes_MTX_3h_vs_Control_3h.csv", "all_diff_genes_MTX_3h_vs_Control_3h.csv","Volcano plot: MTX_3h_vs_Control_3h", "Volcano_plot_MTX_3h_vs_Control_3h.pdf", "Volcano_plot_MTX_3h_vs_Control_3h_widget.html")





# If I want to evaluate how many differentially expressed genes overlap across the drugs, and/or which drug has the most effect on the cell lines, at a specific timepoint (3h for example) ?


## How do I proceed ?

# for visualization
library(ggvenn)



# Create Venn Diagram showing the number of DEGs in each condition as well as the overlap across conditions
get_venn_diagram_intersect_degs <- function(fit_contrast, timepoint, coef_interest_MTX_vs_Control, coef_interest_OXA_vs_Control, coef_interest_CIS_vs_Control){
  
  
  # Recall: 3 drugs = Mitoxantrone (MTX), Oxaliplatin (CIS), Cisplatin (CIS) + Control (for untreated)
  
  # Get gene symbols for up-reg genes in cell lines treated with MTX
  results_dea_MTX_vs_Control <- topTable(fit_contrast, sort.by= "P", adjust.method = "BH", number = Inf, coef = coef_interest_MTX_vs_Control) %>%
    rownames_to_column("gene_name") %>% filter(logFC > 0 & adj.P.Val <= 0.05) %>% dplyr::select("gene_name")
  
  # Get gene symbols for up-reg genes in cell lines treated with OXA
  results_dea_OXA_vs_Control <- topTable(fit_contrast, sort.by= "P", adjust.method = "BH", number = Inf, coef = coef_interest_OXA_vs_Control) %>% rownames_to_column("gene_name") %>% filter(logFC > 0 & adj.P.Val <= 0.05) %>% dplyr::select("gene_name")
  
  
  # Get gene symbols for up-reg genes in cell lines treated with CIS
  results_dea_CIS_vs_Control <- topTable(fit_contrast, sort.by= "P", adjust.method = "BH", number = Inf, coef = coef_interest_CIS_vs_Control) %>%
    rownames_to_column("gene_name") %>% filter(logFC > 0 & adj.P.Val <= 0.05) %>% dplyr::select("gene_name")
  
  
  # Plot results as a Venn diagram
  ggvenn(as.factor(paste0("MTX_",timepoint,"_vs_","Control_",timepoint)) = results_dea_MTX_vs_Control, as.factor(paste0("OXA_",timepoint,"_vs_","Control_",timepoint)) = results_dea_OXA_vs_Control, as.factor(paste0("CIS_",timepoint,"_vs_","Control_",timepoint)) = results_dea_CIS_vs_Control)
  
}


# Call the function at 3h

get_venn_diagram_intersect_degs(fit_contrast_3h, "3h", MTX_3h_vs_Control_3h, OXA_3h_vs_Control_3h, CIS_3h_vs_Control_3h)



# If you want to evaluate the effect of a certain drug over another drug, such as Cisplatin vs Oxaliplatin or/and Cisplatin vs Mitoxantrone, at a specific timepoint (3h for example)


## How do I proceed ?


# Specify sample groups to compare 
contrasts_for_dea_3h_drug_vs_drug <- makeContrasts(CIS_3h_vs_MTX_3h = CIS_3h - MTX_3h, CIS_3h_vs_OXA_3h = CIS_3h - OXA_3h, levels = dsgn)

# Estimate contrast for each gene 
fit_contrast_3h_drug_vs_drug <- contrasts.fit(fit_dea, contrasts_for_dea_3h_drug_vs_drug)

# Empirical Bayes smoothing of standard errors
fit_contrast_3h_drug_vs_drug <- eBayes(fit_contrast_3h_drug_vs_drug)



# Get results from DEA

# CIS vs MTX
get_results_dea(fit_contrast_3h_drug_vs_drug, "CIS_3h_vs_MTX_3h", "top_table_genes_CIS_3h_vs_MTX_3h.csv", "up_reg_genes_CIS_3h_vs_MTX_3h.csv", "down_reg_genes_CIS_3h_vs_MTX_3h.csv", "up_and_down_reg_genes_CIS_3h_vs_Control_3h.csv", "all_diff_genes_CIS_3h_vs_MTX_3h.csv","Volcano plot: CIS_3h_vs_MTX_3h", "Volcano_plot_CIS_3h_vs_MTX_3h.pdf", "Volcano_plot_CIS_3h_vs_MTX_3h_widget.html")


# CIS vs OXA
get_results_dea(fit_contrast_3h_drug_vs_drug, "CIS_3h_vs_OXA_3h", "top_table_genes_CIS_3h_vs_OXA_3h.csv", "up_reg_genes_CIS_3h_vs_OXA_3h.csv", "down_reg_genes_CIS_3h_vs_OXA_3h.csv", "up_and_down_reg_genes_CIS_3h_vs_OXA_3h.csv", "all_diff_genes_CIS_3h_vs_OXA_3h.csv","Volcano plot: CIS_3h_vs_OXA_3h", "Volcano_plot_CIS_3h_vs_OXA_3h.pdf", "Volcano_plot_CIS_3h_vs_OXA_3h_widget.html")



# If now I want to evaluate the effect of time for a given drug.
# For example, I want to see if there are some genes for which their expression change between 12h and 6h, in cell lines treated with Mitoxantrone (MTX)

# How do I proceed ?


# Prepare contrast for differential analysis
contrasts_dea_MTX_all_timepoints <- makeContrasts(MTX_6h_vs_MTX_3h = MTX_6h - MTX_3h, MTX_12h_vs_MTX_6h = MTX_12h - MTX_6h, MTX_18h_vs_MTX_12h = MTX_18h - MTX_12h, MTX_24h_vs_MTX_18h = MTX_24h - MTX_18h, levels=dsgn)


# Estimate contrast for each gene 
fit_contrast_MTX <- contrasts.fit(fit_dea, contrasts_dea_MTX_all_timepoints)



# Empirical Bayes smoothing of standard errors (i.e. shrinks standard errors that are much larger or smaller than those from other genes towards the average standard error)
fit_contrast_MTX <- eBayes(fit_contrast_MTX)


# Get the DEA results for MTX_12h_vs_MTX_6h
get_results_dea(fit_contrast_MTX, "MTX_12h_vs_MTX_6h", "top_table_genes_MTX_12h_vs_MTX_6h.csv", "up_reg_genes_MTX_12h_vs_MTX_6h.csv", "down_reg_genes_MTX_12h_vs_MTX_6h.csv", "up_and_down_reg_genes_MTX_12h_vs_MTX_6h.csv", "all_diff_genes_MTX_12h_vs_MTX_6h.csv","Volcano plot: MTX_12h_vs_MTX_6h", "Volcano_plot_MTX_12h_vs_MTX_6h.pdf", "Volcano_plot_MTX_12h_vs_MTX_6h_widget.html")


# Another example: How does the gene expression statistically change in OXA-treated cell lines between 18h and 24h ?

# Just need to replace MTX by OXA, when preparing and estimating the contrasts, as follows.

contrasts_dea_OXA_all_timepoints <- makeContrasts(OXA_6h_vs_OXA_3h = OXA_6h - OXA_3h, OXA_12h_vs_OXA_6h = OXA_12h - OXA_6h, OXA_18h_vs_OXA_12h = OXA_18h - OXA_12h, OXA_24h_vs_OXA_18h = OXA_24h - OXA_18h, levels=dsgn)
fit_contrast_OXA <- contrasts.fit(fit_dea, contrasts_dea_OXA_all_timepoints)
fit_contrast_OXA <- eBayes(fit_contrast_OXA)

# Get results for OXA
get_results_dea(fit_contrast_OXA, "OXA_18h_vs_OXA_6h", "top_table_genes_OXA_18h_vs_OXA_6h.csv", "up_reg_genes_OXA_18h_vs_OXA_6h.csv", "down_reg_genes_OXA_18h_vs_OXA_6h.csv", "up_and_down_reg_genes_OXA_18h_vs_OXA_6h.csv", "all_diff_genes_OXA_18h_vs_OXA_6h.csv","Volcano plot: OXA_18h_vs_OXA_6h", "Volcano_plot_OXA_18h_vs_OXA_6h.pdf", "Volcano_plot_OXA_18h_vs_OXA_6h_widget.html")

```


# **4. Pathway enrichment analysis**


```{r eval=FALSE, echo=TRUE}


# If now I aim to evaluate the effect of the drugs at at pathway level, at a specific timepoint, such as 3h.


## Which approach can I take ?


## 1. Over-representation analysis (ORA)


### 1.1. I want to statistically test which Gene Ontology terms are over-represented in my list of DEGs.


### How do I proceed ?

# Function for visualization of enriched GO terms
# Top 20 are plotted (for visualization purpose)
enrich_plot_go <- function(test){
if (nrow(test) >= 20){
  ggplot(data = test[1:20,], 
       mapping = aes(x = prop_overlap,
                     y = Biological_Processes,
                     color = p.adjust,
                     size = prop_overlap
                     )
       ) + 
geom_point() + 
scale_color_gradient(low = "red", high = "blue") + 
theme_bw() +
xlab("Proportion of Overlap (in %)") +
ylab("Biological Processes") +
theme(axis.text= element_text(face = "bold")) +
theme(axis.title.x = element_text(size = 9)) 
}
else {
    ggplot(data = test, 
       mapping = aes(x = prop_overlap,
                     y = reorder(Biological_Processes,prop_overlap),
                     color = p.adjust,
                     size = prop_overlap
                     )
       ) + 
geom_point() + 
scale_color_gradient(low = "red", high = "blue") + 
theme_bw() +
xlab("Proportion of Overlap (in %)") +
ylab("Biological Processes") +
theme(axis.text= element_text(face = "bold")) +
theme(axis.title.x = element_text(size = 9))
}
}


# Get enrichment results using GO terms + plot them
# Enrichment ran on the up-reg genes and down-reg genes, separately.
get_go_results <- function(diff_genes_filename, enriched_go_terms_up_reg_genes_filename, enriched_go_terms_down_reg_genes_filename, dotplot_enriched_go_terms_up_reg_genes_filename, dotplot_enriched_go_terms_down_reg_genes_filename){
  
  
  # Get diff genes (up-reg, and down-reg genes)
  diff_genes <- read.csv(diff_genes_filename)
  diff_up <- diff %>% filter(group == "up")
  diff_down <- diff %>% filter(group == "down")
  
  
  # Get gene symbols
  diff_up_symbol <- diff_up$genes
  diff_down_symbol <- diff_down$genes
  
  # Retrieve ENTREZ ID (in addition to ENSEMBL)
  bitr_up <- bitr(diff_up_symbol, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = "org.Mm.eg.db")
  bitr_down <- bitr(diff_down_symbol, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = "org.Mm.eg.db")
  
  # Get ENTREZ ID for list 
  bitr_up_list <- list(genes = bitr_up$ENTREZID)
  bitr_down_list <- list(genes = bitr_down$ENTREZID)
  
  # Run GO enrichment analysis (with the 3 subontologies: BP, MF, CC)
  # BP: Biological process, MF: Molecular Function, CC: Cellular Component.
  go_analysis_up_df <- enrichGO(bitr_up_list$genes, ont="ALL", OrgDb = "org.Mm.eg.db", readable = TRUE)
  go_analysis_down_df <- enrichGO(bitr_down_list$genes, ont="ALL", OrgDb = "org.Mm.eg.db", readable = TRUE)
  
  
  
  # Remove redundant enriched GO terms
  go_analysis_up_df_not_redundant <- simplify(go_analysis_up_df, cutoff=0.7, by="p.adjust", select_fun=min)
  go_analysis_down_df_not_redundant <- simplify(go_analysis_down_df, cutoff=0.7, by="p.adjust", select_fun=min)
  
  
  # Compute proportion of genes in the GO term that overlaps with our lists of DEGs
  
  # up
  go_analysis_up_df_not_redundant <- go_analysis_up_df_not_redundant %>% dplyr::mutate(prop_overlap  = as.integer(str_remove(GeneRatio, "/.*")) / as.integer(str_remove(BgRatio, "/.*")), Biological_Processes = Description)
  
  # down
  go_analysis_down_df_not_redundant <- go_analysis_down_df_not_redundant %>% dplyr::mutate(prop_overlap  = as.integer(str_remove(GeneRatio, "/.*")) / as.integer(str_remove(BgRatio, "/.*")), Biological_Processes = Description)
  
  
  # Convert prop overlap in percentage
  
  # up
  go_analysis_res_bitr_up_df_not_redundant <- go_analysis_res_bitr_up_df_not_redundant %>% mutate(prop_overlap = prop_overlap * 100)
  
  # down
  go_analysis_res_bitr_down_df_not_redundant <- go_analysis_res_bitr_down_df_not_redundant %>% mutate(prop_overlap = prop_overlap * 100)
  

  
  # Rank enriched GO terms by proportion of overlap (in decreasing order) and save

  # up
  ordered_go_analysis_up_df <- go_analysis_up_df_not_redundant[order(go_analysis_up_df_not_redundant$prop_overlap, decreasing = TRUE),] 
  write.csv(ordered_go_analysis_up_df, enriched_go_terms_up_reg_genes_filename)
  
  # down
  ordered_go_analysis_down_df <- go_analysis_down_df_not_redundant[order(go_analysis_down_df_not_redundant$prop_overlap, decreasing = TRUE),] 
  write.csv(ordered_go_analysis_down_df, enriched_go_terms_down_reg_genes_filename)
  

  # Dotplots for visualization and save

  # up
  enrich_plot_go(ordered_go_analysis_up_df)
  ggsave(dotplot_enriched_go_terms_up_reg_genes_filename, width=12, height=4)
  
  # down
  enrich_plot_go(ordered_go_analysis_down_df)
  ggsave(dotplot_enriched_go_terms_down_reg_genes_filename, width=12, height=4)

}


# Call the function (drug: MTX and timepoint: 3h)

get_go_results(diff_genes_filename = "/data/users/tlassale/MODICED_link/Bulk_RNA_in_vitro/in_vitro_results/gene_list_MTX_vs_PBS_3h.csv", 
               dotplot_enriched_go_terms_up_reg_genes_filename = "/data/users/tlassale/MODICED_link/Bulk_RNA_in_vitro/in_vitro_results/GO enrichment (up reg genes): MTX(3h)_vs_PBS(3h).png", 
               dotplot_enriched_go_terms_down_reg_genes_filename = "/data/users/tlassale/MODICED_link/Bulk_RNA_in_vitro/in_vitro_results/GO enrichment (down reg genes): MTX(3h)_vs_PBS(3h).png",
               enriched_go_terms_up_reg_genes_filename = "/data/users/tlassale/MODICED_link/Bulk_RNA_in_vitro/in_vitro_results/enriched_go_terms_MTX(3h)_vs_PBS(3h)_up_genes.csv", 
               enriched_go_terms_down_reg_genes_filename = "/data/users/tlassale/MODICED_link/Bulk_RNA_in_vitro/in_vitro_results/enriched_go_terms_MTX(3h)_vs_PBS(3h)_down_genes.csv")





# If now I want to investigate how much time a pathway or biological function stays up or down-regulated
# As an example, if some immunology pathways are "up" at 3h following treatment with Mitoxantrone, are they still up at 24h ? Or the treatment effect on these pathways was temporary ?


# How do I proceed ?



 # Venn diagram showing the number of up-regulated pathways overlapping across time (+ save it)
get_venn_diagram_for_intersect_up_regulated_pathways <- function(drug, timepoint1, timepoint2, timepoint3, timepoint4, timepoint5){
  
 
  
  # Load up-regulated pathways at timepoint1
  up_reg_pathways_drug_interest_timepoint1 <- read.csv(paste0("/data/users/tlassale/MODICED_link/Bulk_RNA_in_vitro/in_vitro_results/enriched_go_terms_",drug,"(",timepoint1,")","_vs_","PBS","(",timepoint1,")","_up_genes.csv"))
  
  # Load up-regulated pathways at timepoint2
  up_reg_pathways_drug_interest_timepoint2 <- read.csv(paste0("/data/users/tlassale/MODICED_link/Bulk_RNA_in_vitro/in_vitro_results/enriched_go_terms_",drug,"(",timepoint2,")","_vs_","PBS","(",timepoint2,")","_up_genes.csv"))
  
  ## Load up-regulated pathways at timepoint3
  up_reg_pathways_drug_interest_timepoint3 <- read.csv(paste0("/data/users/tlassale/MODICED_link/Bulk_RNA_in_vitro/in_vitro_results/enriched_go_terms_",drug,"(",timepoint3,")","_vs_","PBS","(",timepoint3,")","_up_genes.csv"))
  
  
  ## Load up-regulated pathways at timepoint4
  up_reg_pathways_drug_interest_timepoint4 <- read.csv(paste0("/data/users/tlassale/MODICED_link/Bulk_RNA_in_vitro/in_vitro_results/enriched_go_terms_",drug,"(",timepoint4,")","_vs_","PBS","(",timepoint4,")","_up_genes.csv"))
  
  
  ## Load up-regulated pathways at timepoint5
  up_reg_pathways_drug_interest_timepoint5 <- read.csv(paste0("/data/users/tlassale/MODICED_link/Bulk_RNA_in_vitro/in_vitro_results/enriched_go_terms_",drug,"(",timepoint5,")","_vs_","PBS","(",timepoint5,")","_up_genes.csv"))

  
  
  
  # Create a list that contains the up-regulated pathways in each condition for Venn Diagram
  list_intersect_go_terms <- list(as.factor(paste0(drug,"_",timepoint1,"_vs_","PBS","_",timepoint1)) = 
                                  up_reg_pathways_drug_interest_timepoint1$Biological_Processes, 
                                  as.factor(paste0(drug,"_",timepoint2,"_vs_","PBS","_",timepoint2)) = 
                                  up_reg_pathways_drug_interest_timepoint2$Biological_Processes, 
                                  as.factor(paste0(drug,"_",timepoint3,"_vs_","PBS","_",timepoint3)) =   
                                  up_reg_pathways_drug_interest_timepoint3$Biological_Processes, 
                                  as.factor(paste0(drug,"_",timepoint4,"_vs_","PBS","_",timepoint4)) = 
                                  up_reg_pathways_drug_interest_timepoint4$Biological_Processes, 
                                  as.factor(paste0(drug,"_",timepoint5,"_vs_","PBS","_",timepoint5)) = 
                                  up_reg_pathways_drug_interest_timepoint5$Biological_Processes)
  
  
  ggvenn(list_intersect_go_terms, stroke_size = 0.5)
  ggsave(paste0("/data/users/tlassale/MODICED_link/Bulk_RNA_in_vitro/in_vitro_results/overlapping_enriched_go_terms_venn_",drug,"_vs_PBS_",timepoint1,"_",timepoint2,"_",timepoint3,"_",timepoint4,"_",timepoint5,"_up_genes.png"))
  
  
}


# Call the Venn diagram function
# drug = MTX with 5 timepoints (3h up to 24h)
get_venn_diagram_for_intersect_up_regulated_pathways("MTX", "3h", "6h", "12h", "18h", "24h")
  
  
  
# If you want to investigate which are these overlapping up-reg pathways, you just need to call the intersect() function
# Here below are two examples, where we want to get the pathways overlapping between 1st and 2nd timepoints, as well as between 2nd and 4th timepoints. You are free to test any drug you want here, by filling the argument drug.


  # GO terms up-regulated both at the 1st and 2nd timepoints
  intersect_enriched_go_terms_1st_and_2nd_timepoint <- intersect(up_reg_pathways_drug_interest_timepoint1$Biological_Processes, up_reg_pathways_drug_interest_timepoint2$Biological_Processes)
  write.csv(intersect_enriched_go_terms_1st_and_2nd_timepoint, paste0("/data/users/tlassale/MODICED_link/Bulk_RNA_in_vitro/in_vitro_results/overlapping_enriched_go_terms_",drug,"_vs_PBS_",timepoint1," ",timepoint2,"_up_genes.csv"))
  
  
  # GO terms up-regulated both at the 2nd and 4th timepoint
  intersect_enriched_go_terms_2nd_and_4th_timepoint <- intersect(up_reg_pathways_drug_interest_timepoint2$Biological_Processes, up_reg_pathways_drug_interest_timepoint4$Biological_Processes)
  write.csv(intersect_enriched_go_terms_2nd_and_4th_timepoint, paste0("/data/users/tlassale/MODICED_link/Bulk_RNA_in_vitro/in_vitro_results/overlapping_enriched_go_terms_",drug,"_vs_PBS_",timepoint1," _",timepoint2,"_up_genes.csv"))
  
  
  


# Few comments
# Here I looked at the intersection of up-regulated pathways across my 5 timepoints, but if you are only interest in a restricted number of timepoints, you are free to rewrite this function, by changing the number of timepoints as an argument of the function.
# Here I looked at the up-regulated pathways, but we could do the same for down-regulated pathways.
  



# If now I want to evaluate if there are similarities in the response to each drug, at the pathway level, at a specific timepoint.


## How do I proceed ?



# Example of up-regulated pathways, but again this is the same logic for down-reg.
get_venn_diagram_for_intersect_up_regulated_pathways_same_timepoint_diffrent_drugs <- function(drug1, drug2, timepoint_interest, overlap_up_reg_pathways_drug1_drug2_timepoint_interest_filename){
  
  
  # Load up-reg pathways at timepoint_interest, with drug1
  up_reg_pathways_drug1_timepoint_interest <- read.csv(paste0("/data/users/tlassale/MODICED_link/Bulk_RNA_in_vitro/in_vitro_results/enriched_go_terms_",drug1,"(",timepoint_interest,")","_vs_","PBS","(",timepoint_interest,")","_up_genes.csv"))
  
  
  # Load up-reg pathways at timepoint_interest, with drug2
  up_reg_pathways_drug2_timepoint_interest <- read.csv(paste0("/data/users/tlassale/MODICED_link/Bulk_RNA_in_vitro/in_vitro_results/enriched_go_terms_",drug2,"(",timepoint_interest,")","_vs_","PBS","(",timepoint_interest,")","_up_genes.csv"))
  
  
  # Create a list of up-regulated pathways in each condition for Venn Diagram
  intersect_go_terms <- list(paste0(drug1,"_",timepoint_interest,"_vs_","PBS","_",timepoint_interest) = up_reg_pathways_drug1_timepoint_interest$Biological_Processes, paste0(drug2,"_",timepoint_interest,"_vs_","PBS","_",timepoint_interest) = up_reg_pathways_drug2_timepoint_interest$Biological_Processes)
  
  ggvenn(intersect_go_terms, stroke_size = 0.5)
  ggsave(paste0("/data/users/tlassale/MODICED_link/Bulk_RNA_in_vitro/in_vitro_results/overlapping_enriched_go_terms_venn_",drug1,"(",timepoint_interest,")","_vs_","PBS","(",timepoint_interest,")","_",drug2,"(",timepoint_interest,")","_vs_","PBS","(",timepoint_interest,")","_up_genes.png"))

  }


# Call the Venn diagram function
# drug1 = MTX, drug2 = OXA, timepoint_interest = 3h
get_venn_diagram_for_intersect_up_regulated_pathways_same_timepoint_diffrent_drugs("MTX","OXA","3h", paste0("/data/users/tlassale/MODICED_link/Bulk_RNA_in_vitro/in_vitro_results/overlapping_go_terms_",drug1,"(",timepoint_interest,")","_vs_","PBS","(",timepoint_interest,")","_vs_",drug2,"(",timepoint_interest,")","_vs_","PBS","(",timepoint_interest,")","_up_genes.csv"))



# A comment about the Venn diagram function 
# Here I tested only 2 drugs, but you can test more, only by adding more drugs as an argument of the function.




# If you want to investigate which are these overlapping pathways, you just need to call the intersect() function

# From the code below, if we want to investigate which up-regulated pathways overlap at 12h following MTX and OXA treatments.
# Just need to input drug1 and drug2 by MTX an OXA respectively, as well as timepoint_interest by 12.

intersect_go_terms <- intersect(up_reg_pathways_drug1_timepoint_interest$Biological_Processes, up_reg_pathways_drug2_timepoint_interest$Biological_Processes)
write.csv(intersect_go_terms, paste0("/data/users/tlassale/MODICED_link/Bulk_RNA_in_vitro/in_vitro_results/overlapping_enriched_go_terms_venn_",drug1,"(",timepoint_interest,")","_vs_","PBS","(",timepoint_interest,")","_",drug2,"(",timepoint_interest,")","_vs_","PBS","(",timepoint_interest,")","_up_genes.png"))



## If now you want to investigate the enrichment of other collection of gene sets such as Reactome or Kegg pathways, this is the same logic, what do you need to modify from the code above explicitely ?

### For Reactome database.

# 1. In enrich_plot_go: replace Biological_Processes by Reactome_Pathway
# 2. In get_go: replace enrichGO by enrichPathway, with only the list of DEGs and the name of the organism as input.
# 3. the simplify function (from clusterProfiler package) only works for enriched GO terms.


## For Kegg database.

# 1. In enrich_plot_go: replace Biological_Processes by Kegg_Pathway
# 2. In get_go: replace enrichGO by enrichKEGG, with again only the list of DEGs and the organism as input.
# 3. Again, no simplify function.



## But (as you might now), results from over-representation analysis (ORA) change a lot depending on your thresholds (i.e. logFC and adj.P.Val). To overcome this limitation, you might undertake gene set enrichment analysis (GSEA)


## 2. Gene Set Enrichment analysis (GSEA)


# So if I want to investigate which GO term is over-represented at the top of the ranked list of genes (i.e. up-regulated).



# How do I proceed ?


# Function providing GSEA results, including:
# 1. A dataframe containing gsea output filtered on the enriched GO terms.
# 2. GSEA plot for each of the enriched GO term.
# 3. A dataframe containing the leading edge subset of gene set (i.e. the genes contributing most to the enrichment score): including their ranking score (i.e. -log10(adj.P.Val) * sign(logFC)), and the enriched GO term assigned to them.


run_gsea <- function(top_table_filename, directory_interest, contrast_interest){
  
  # From DEA output and contrast of interest, rank (decreasingly) the list of genes (by: -log10(adj.P.Val) * sign(logFC)).
  top_table_contrast_interest <- read.csv(top_table_filename) %>% filter(contrast == contrast_interest) %>% mutate(rank = sign(logFC) * -log10(adj.P.Val)) %>% arrange(desc(rank))
  
  # Retrieve the ranking score column
  gene_list_interest <- top_table_contrast_interest$rank
  
  # Retrieve the gene names column and put it as row names
  names(gene_list_interest) <- top_table_contrast_interest$genes
  
  # Run GSEA of Gene Ontology (retrieved the Biological Processes from GO)
  gsea_contrast_interest <- gseGO(gene_list_interest, ont = "BP", OrgDb = "org.Mm.eg.db", keyType = "SYMBOL", eps=0)
  
  # Retrieve the up-regulated GO terms, and sort them (decreasingly) by their normalised enrichment score.
  # A comment about the normalised enrichment score: it accounts for differences in gene set sizes, unlike the standard enrichment score.
  gsea_contrast_interest_up_reg_pathways <- gsea_contrast_interest %>% as.data.frame() %>% filter(NES > 0 & p.adjust <= 0.05) %>% arrange(desc(NES))
  
  
  # Save results
  write.csv(gsea_contrast_interest_up_reg_pathways, paste0(directory_interest,"/up_enriched_sets_gsea_",contrast_interest,".csv"), col.names = TRUE, row.names = TRUE)
  
  
  # Visualization of results (only up-regulated GO terms)
  for (i in 1:nrow(gsea_contrast_interest_up_reg_pathways)){
    gseaplot(gsea_contrast_interest_up_reg_pathways, geneSetID = i, by="runningScore", title = gsea_contrast_interest_up_reg_pathways$Description[i]) + theme(plot.title = element_text(face = "bold", hjust=0.5)) + theme(axis.title.x = element_text(face = "")) + theme(axis.title.x = element_text(size = 15, face="italic")) + theme(axis.title.y = element_text(size=15, face="italic"))
  }
  
  
  # Save results
  ggsave(paste0(directory_interest,"/",gsea_contrast_interest$Description[i],".png"))
  
  
  
  # Split the strings in the core_enrichment column (from gseGO output restricted to up-reg GO terms) on " "
  for (i in 1:dim(gsea_contrast_interest_up_reg_pathways)[1]) {
    
    gsea_contrast_interest_up_reg_pathways$core_enrichment[i] <- str_split(gsub("/"," ", gsea_contrast_interest_up_reg_pathways$core_enrichment[i]), " ")
    
  }
  
  
  # Store leading edge subset of genes + their ranking score + their associated GO term (for each up-reg GO term), in a dataframe
  leading_edge_ranked_genes <- data.frame(matrix(nrow = 0, ncol = 1))
  colnames(leading_edge_ranked_genes) <- "leading_edge_genes_ranking_score"
  for (i in 1:dim(gsea_contrast_interest_up_reg_pathways)[1]) {
    
    leading_edge_ranked_genes <- rbind(leading_edge_ranked_genes, gene_list_interest[gsea_contrast_interest_up_reg_pathways$core_enrichment[i] %>% unlist()] %>% as.data.frame(row.names = names(gene_list_interest[gsea_contrast_interest_up_reg_pathways$core_enrichment[i] %>% unlist()])) %>%  dplyr::rename("leading_edge_genes_ranking_score" = ".") %>% mutate("up_pathways" = rep(gsea_contrast_interest_up_reg_pathways$Description[i], length(gsea_contrast_interest_up_reg_pathways$core_enrichment[i]))))
  }
  
  # Save df
  write.csv(leading_edge_ranked_genes, paste0(directory_interest,"/leading_edge_genes_up_enriched_sets_gsea_",contrast_interest,".csv"), col.names = TRUE, row.names = TRUE)
  
}


# Call the function
# As an example, I want to retrieve up-reg go terms, the corresponding gsea plots, as well as the leading edge subset of genes with their ranking score, between the cell lines treated with MTX and those untreated, after 3h (i.e. MTX(3h) vs Control(3h)).
# I keep directory of interest as an argument (feel free to fill it in with your directory)
run_gsea("Bulk_RNA_in_vitro/in_vitro_results/top_table_drug_control_in_vitro.csv", directory_interest, "MTX_3h_vs_Control_3h")



## If now I want to investigate the overlap of up-reg pathways after a certain timepoint, across each treatment.
# I assume that there are 3 drugs.


get_Venn_diagramm_for_overlap_up_pathways <- function(top_table_filename, contrast_interest_drug1, contrast_interest_drug2, contrast_interest_drug3, drug1, drug2, drug3, timepoint_interest){
  
  
  # Get up-reg pathways for drug1
  top_table_contrast_interest_drug1 <- read.csv(top_table_filename) %>% filter(contrast == contrast_interest_drug1) %>% mutate(rank = sign(logFC) * -log10(adj.P.Val)) %>% arrange(desc(rank))
  
  # Retrieve the ranking score column
  gene_list_interest <- top_table_contrast_interest_drug1$rank
  
  # Retrieve the gene names column and put it as row names
  names(gene_list_interest) <- top_table_contrast_interest_drug1$genes
  
  # Run GSEA of Gene Ontology (retrieved the Biological Processes from GO)
  gsea_contrast_interest_drug1 <- gseGO(gene_list_interest, ont = "BP", OrgDb = "org.Mm.eg.db", keyType = "SYMBOL", eps=0)
  
  # Retrieve the up-regulated GO terms, and sort them (decreasingly) by their normalised enrichment score.
  gsea_contrast_interest_drug1_up_reg_pathways <- gsea_contrast_interest_drug1 %>% as.data.frame() %>% filter(NES > 0 & p.adjust <= 0.05) %>% arrange(desc(NES))
  
  
  
   # Get up-reg pathways for drug2
  top_table_contrast_interest_drug2 <- read.csv(top_table_filename) %>% filter(contrast == contrast_interest_drug2) %>% mutate(rank = sign(logFC) * -log10(adj.P.Val)) %>% arrange(desc(rank))
  
  # Retrieve the ranking score column
  gene_list_interest <- top_table_contrast_interest_drug2$rank
  
  # Retrieve the gene names column and put it as rownames
  names(gene_list_interest) <- top_table_contrast_interest_drug2$genes
  
  # Run GSEA of Gene Ontology (retrieved the Biological Processes from GO)
  gsea_contrast_interest_drug2 <- gseGO(gene_list_interest, ont = "BP", OrgDb = "org.Mm.eg.db", keyType = "SYMBOL", eps=0)
  
  # Retrieve the up-regulated GO terms, and sort them (decreasingly) by their normalised enrichment score.
  gsea_contrast_interest_drug2_up_reg_pathways <- gsea_contrast_interest_drug2 %>% as.data.frame() %>% filter(NES > 0 & p.adjust <= 0.05) %>% arrange(desc(NES))
  
  
  # Get up-reg pathways for drug3
   top_table_contrast_interest_drug3 <- read.csv(top_table_filename) %>% filter(contrast == contrast_interest_drug3) %>% mutate(rank = sign(logFC) * -log10(adj.P.Val)) %>% arrange(desc(rank))
  
  # Retrieve the ranking score column
  gene_list_interest <- top_table_contrast_interest_drug3$rank
  
  # Retrieve the gene names column ans put it as rownames
  names(gene_list_interest) <- top_table_contrast_interest_drug3$genes
  
  # Run GSEA of Gene Ontology (retrieved the Biological Processes from GO)
  gsea_contrast_interest_drug3 <- gseGO(gene_list_interest, ont = "BP", OrgDb = "org.Mm.eg.db", keyType = "SYMBOL", eps=0)
  
  # Retrieve the up-regulated GO terms, and sort them (decreasingly) by their normalised enrichment score.
  gsea_contrast_interest_drug3_up_reg_pathways <- gsea_contrast_interest_drug3 %>% as.data.frame() %>% filter(NES > 0 & p.adjust <= 0.05) %>% arrange(desc(NES))
  
  
  # Create a list of up-regulated pathways in each condition for Venn Diagram 
  intersect_go_terms <- list(paste0(drug1,"_",timepoint_interest,"_vs_","PBS","_",timepoint_interest) = gsea_contrast_interest_drug1_up_reg_pathways$Description, paste0(drug2,"_",timepoint_interest,"_vs_","PBS","_",timepoint_interest) = gsea_contrast_interest_drug2_up_reg_pathways$Description, paste0(drug3,"_",timepoint_interest,"_vs_","PBS","_",timepoint_interest) = gsea_contrast_interest_drug3_up_reg_pathways$Description)
  
  
  # Venn diagram
  ggvenn(intersect_go_terms, stroke_size = 0.5)
  ggsave(paste0("/data/users/tlassale/MODICED_link/Bulk_RNA_in_vitro/in_vitro_results/overlapping_enriched_go_terms_venn_",drug1,"(",timepoint_interest,")","_vs_","PBS","(",timepoint_interest,")","_",drug2,"(",timepoint_interest,")","_vs_","PBS","(",timepoint_interest,")",drug3,"(",timepoint_interest,")","_vs_","PBS","(",timepoint_interest,")","_up_genes.png"))
  
  
  }


# Call the function
# 3 drugs: MTX, OXA, CIS
# Timepoint of interest: 24h
get_Venn_diagramm_for_overlap_up_pathways("Bulk_RNA_in_vitro/in_vitro_results/top_table_drug_control_in_vitro.csv", "MTX_24h_vs_Control_24h", "OXA_24h_vs_Control_24h", "CIS_24h_vs_Control_24h", "MTX", "OXA", "CIS", "24h")



## If you want to retrieve these overlapping up-reg pathways across the conditions, you just need to call the intersect() function, as in the function above.

  

## 3. Pathway activity inference using decoupleR and ROMA (Representation of module activity from omics data).


# ROMA (Representation and Quantification of Module Activity): an algorithm, implemented as an R package called rRoma, which was designed to quantify the activity of gene sets characterized by their involvement in a common functional role. Mathematically speaking, it works by computing the first principal component of the expression matrix restricted to the genes in the gene set. As an output, a gene set with an interesting activity, will be either deemed as shifted (i.e. the gene set shows a particularly high  expression in at least one sample = median PC1 projections is high) or overdispersed (i.e. high variability of the gene set across the considered samples = % of variance captured by PC1 is high). The statistical significance of shift and overdispersion is calculated using random collection of set of genes of the same size. If you want more details about the way this algorithm works, refer to the following tutorial (from github): https://github.com/sysbio-curie/rROMA


# So now you might wonder, how can I run this algorithm concretely ? What do you need as input to run it? 

# How do I proceed ?


# Put gene_name as rownames
rownames(counts_in_vitro_df) <- make.names(counts_in_vitro_df$gene_name, unique=TRUE)

# Remove gene_id, gene_type, and gene_name as columns.
counts_in_vitro_df <- counts_in_vitro_df %>% dplyr::select(-c("gene_id", "gene_type", "gene_name"))


# Convert read counts to cpm.
counts_in_vitro_df <- cpm(counts_in_vitro_df, log=TRUE)

# Load the HALLMARK gene sets (gmt file).
# A comment: before to load the gmt file, 
hallmark_gene_sets_gmt <- ReadGMTFile("/data/users/tlassale/MODICED_link/hallmark_gene_symbols.gmt")


# Load library tu use roma algorithm
library(rRoma)


# Launch rRoma
# As en example, I decided to quantify activity of hallmark gene sets over MTX-treated vs untreated cell lines (at 24h)
# Inputs of the rRoma.R function:
# 1) Normalised count matrix (here I used cpm from edgeR for normalisation)
# 2) gmt file (here I extracted hallmark gene sets from MSigDB)
run_roma_MTX_vs_Control_24h <- rRoma.R(counts_in_vitro_df %>% dplyr::select(contains("24h")) %>% dplyr::select(contains("MTX") | contains("Control")), hallmark_gene_sets_gmt)

# Save roma ouptut
filename <- "..."
saveRDS(run_roma_MTX_vs_Control_24h, filename)



# So now that I ran the algorithm, I want to retrieve shifted and overdispersed pathways, and to plot them accordingly.

# How do I proceed ?



# Get shifted modules (here focus on HALLMARK gene sets)
# What does this function perform ?
# 1) Retrieve shifted modules and store them (arranged by the p-value associated to the shift)
# 2) Get top 50 contributing genes for the activity scores of the shifted pathways
# 3) Plot (+save) the activity scores of the top 20 shifted modules (arranged by p-value), using roma-based function and ComplexHeatmap package.

get_shifted_modules <- function(roma_output_filename, shifted_modules_matrix_filename, shifted_modules_matrix_top_20_filename, top_20_shifted_modules_roma_heatmap_filename, top_20_shifted_modules_complex_heatmap_filename){
  
  # Load roma output
  roma_output <- readRDS(roma_output_filename)
  
  # Remove (from module matrix) HALLMARK prefix in front of each gene set name
  rownames(roma_output$ModuleMatrix) <- gsub("HALLMARK_", "", rownames(roma_output$ModuleMatrix))
  rownames(roma_output$SampleMatrix) <- gsub("HALLMARK_", "", rownames(roma_output$SampleMatrix))
  
  # Get the index of the shifted modules in the module matrix (for plotting)
  shifted_modules_index <- which(roma_output$ModuleMatrix[,"ppv Median Exp"] <= 0.05)
  
  
  # Restrict the module matrix to the shifted modules and sort them by their p-value (+ save)
  shifted_modules_matrix <- roma_output$ModuleMatrix %>% as.data.frame() %>% dplyr::filter(`ppv Median Exp`<= 0.05) %>% dplyr::arrange(`ppv Median Exp`)%>% rownames_to_column("shifted_modules")
  write.csv(shifted_modules_matrix, shifted_modules_matrix_filename)
  
  
  
  # Get top contributing genes of shifted pathways + Save them
  # I retrieve top 50 here (bu you are free to retrieve more)
  
  
  # Loop through the module matrix restricted to the shifted modules
  for (i in 1:nrow(shifted_modules_matrix)){
    
     # Get top 50 contributing genes for the activity scores of the underlying shifted module (sorted decreasingly by their weight)
    modules_targets_all_info <- GetTopContrib(get_roma_results, Selected = which(rownames(roma_output$ModuleMatrix) == shifted_modules_matrix$shifted_modules[i]), nGenes = 50, OrderType = "Abs", Mode = "Wei", Plot = TRUE)$Table %>% dplyr::select(c("Gene","Weight")) %>% as.data.frame() %>% dplyr::arrange(desc(abs(Weight)))
    
    
    
    # Remove rownames
    rownames(pathway_targets_all_info) <- NULL
    
    # Save top 50 contributing genes matrix
    write.csv(pathway_targets_all_info, paste0(top_contributing_genes_filename, shifted_modules_matrix$shifted_modules[i], "_contributing_genes_activity_score.csv"), col.names = TRUE, row.names = FALSE)
  }
  
  
  
  # Retrieve top 20 shifted modules + Save them
  shifted_modules_matrix_top_20 <- shifted_modules_matrix %>% dplyr::slice(1:20)
  write.csv(shifted_modules_matrix_top_20, shifted_modules_matrix_top_20_filename)
  
  # Plot activity scores of top 20 shifted modules
  # using the Plot.Genesets.Samples() function from roma
  png(top_20_shifted_modules_roma_heatmap_filename, width=1000, height=502)
  Plot.Genesets.Samples(roma_output, Selected = shifted_modules_index[shifted_modules_matrix_top_20$shifted_modules], cluster_cols = TRUE)
  dev.off()
  
  
  
  
  # using ComplexHeatmap package to make a customized heatmap.
  palette_length <- 100
  my_color <- viridis::viridis(palette_length)
  
  # Retrieve activity scores of top 20 shifted modules
  shifted_modules_sample_matrix <- roma_output$SampleMatrix %>% filter(rownames(.) %in% shifted_modules_matrix$shifted_modules)
  shifted_modules_sample_matrix_top_20_arranged <- shifted_modules_sample_matrix[shifted_modules_matrix_top_20,]
  
  # Plot and save them
  png(top_20_shifted_modules_complex_heatmap_filename, width=1000, height=502)
  heatmap_top_20_shifted_modules <- ComplexHeatmap::pheatmap(as.matrix(shifted_modules_sample_matrix_top_20_arranged), color= my_color,cluster_rows = TRUE, cluster_cols = TRUE, fontsize_row = 11, fontsize_col = 11,  main="Top 20 shifted modules", fontface = 3, show_colnames = TRUE, heatmap_legend_param = list(title = "activity_score", title_gp = gpar(fontsize = 10, fontface="bold"), title_position= "topcenter",legend_height = grid::unit(35,"mm"), grid_width = grid::unit(5,"mm"), labels_gp = gpar(col = "black", font = 2), legend_direction = "horizontal", legend_width = unit(5,"cm")), cellwidth = 20) %>% ComplexHeatmap::draw(heatmap_legend_side = "bottom", annotation_legend_side = "right")
  dev.off()
  
}

# Get overdispersed modules (here focus on HALLMARK gene sets)
# What does this function perform ?
# 1) Retrieve overdispersed modules and store them (arranged by the p-value associated to the shift)
# 2) Get top 50 contributing genes for the activity scores of the overdispersed pathways
# 3) Plot (+save) the activity scores of the top 20 overdispersed modules (arranged by p-value), using roma-based function and ComplexHeatmap package.


get_overdispersed_modules <- function(roma_output_filename, overdispersed_modules_matrix_filename, overdispersed_modules_matrix_top_20_filename, top_20_overdispersed_modules_roma_heatmap_filename, top_20_overdispersed_modules_complex_heatmap_filename){
  
  # Load roma output
  roma_output <- readRDS(roma_output_filename)
  
  # Remove (from module matrix) HALLMARK prefix in front of each gene set name
  rownames(roma_output$ModuleMatrix) <- gsub("HALLMARK_", "", rownames(roma_output$ModuleMatrix))
  rownames(roma_output$SampleMatrix) <- gsub("HALLMARK_", "", rownames(roma_output$SampleMatrix))
  
  # Get the index of the overdispersed modules in the module matrix (for plotting)
  overdispersed_modules_index <- which(roma_output$ModuleMatrix[,"ppv Median Exp"] <= 0.05)
  
  
  # Restrict the module matrix to the overdispersed modules and sort them by their p-value (+ save)
  overdispersed_modules_matrix <- roma_output$ModuleMatrix %>% as.data.frame() %>% dplyr::filter(`ppv L1`<= 0.05 & `ppv Median Exp` > 0.05) %>% dplyr::arrange(`ppv L1`) %>% rownames_to_column("overdispersed_modules")
  write.csv(overdispersed_modules_matrix, overdispersed_modules_matrix_filename)
  
  
  
  # Get top contributing genes of overdispersed pathways + Save them
  # I retrieve top 50 here (bu you are free to retrieve more)
  
  
  # Loop through the module matrix restricted to the overdispersed modules
  for (i in 1:nrow(overdispersed_modules_matrix)){
    
     # Get top 50 contributing genes for the activity scores of the underlying overdispersed module (sorted decreasingly by their weight)
    modules_targets_all_info <- GetTopContrib(get_roma_results, Selected = which(rownames(roma_output$ModuleMatrix) == overdispersed_modules_matrix$overdispersed_modules[i]), nGenes = 50, OrderType = "Abs", Mode = "Wei", Plot = TRUE)$Table %>% dplyr::select(c("Gene","Weight")) %>% as.data.frame() %>% dplyr::arrange(desc(abs(Weight)))
    
    
    
    # Remove rownames
    rownames(pathway_targets_all_info) <- NULL
    
    # Save top 50 contributing genes matrix
    write.csv(pathway_targets_all_info, paste0(top_contributing_genes_filename, overdispersed_modules_matrix$overdispersed_modules[i], "_contributing_genes_activity_score.csv"), col.names = TRUE, row.names = FALSE)
  }
  
  
  
  # Retrieve top 20 overdispersed modules + Save them
  overdispersed_modules_matrix_top_20 <- overdispersed_modules_matrix %>% dplyr::slice(1:20)
  write.csv(overdispersed_modules_matrix_top_20, overdispersed_modules_matrix_top_20_filename)
  
  # Plot activity scores of top 20 overdispersed modules
  # using the Plot.Genesets.Samples() function from roma
  png(top_20_overdispersed_modules_roma_heatmap_filename, width=1000, height=502)
  Plot.Genesets.Samples(roma_output, Selected = overdispersed_modules_index[overdispersed_modules_matrix_top_20$overdispersed_modules], cluster_cols = TRUE)
  dev.off()
  
  
  
  
  # using ComplexHeatmap package to make a customized heatmap.
  palette_length <- 100
  my_color <- viridis::viridis(palette_length)
  
  # Retrieve activity scores of top 20 overdispersed modules
  overdispersed_modules_sample_matrix <- roma_output$SampleMatrix %>% filter(rownames(.) %in% overdispersed_modules_matrix$overdispersed_modules)
  overdispersed_modules_sample_matrix_top_20_arranged <- overdispersed_modules_sample_matrix[overdispersed_modules_matrix_top_20,]
  
  # Plot and save them
  png(top_20_overdispersed_modules_complex_heatmap_filename, width=1000, height=502)
  heatmap_top_20_overdispersed_modules <- ComplexHeatmap::pheatmap(as.matrix(overdispersed_modules_sample_matrix_top_20_arranged), color= my_color,cluster_rows = TRUE, cluster_cols = TRUE, fontsize_row = 11, fontsize_col = 11,  main="Top 20 overdispersed modules", fontface = 3, show_colnames = TRUE, heatmap_legend_param = list(title = "activity_score", title_gp = gpar(fontsize = 10, fontface="bold"), title_position= "topcenter",legend_height = grid::unit(35,"mm"), grid_width = grid::unit(5,"mm"), labels_gp = gpar(col = "black", font = 2), legend_direction = "horizontal", legend_width = unit(5,"cm")), cellwidth = 20) %>% ComplexHeatmap::draw(heatmap_legend_side = "bottom", annotation_legend_side = "right")
  dev.off()
  
}



# So now if I want to evaluate the longitudinal up or down-regulation or pathways to answer different questions such as:
# 1. How much time a pathway stays up or down regulated ?
# 2. Does a pathway is up or down regulated at a certain timepoint ?
# As an example, I focus on Reactome pathways (but it is the same logic for gene sets coming from different databases)


# How do I proceed ?


# Drug: MTX
# Timepoints: 3h, 6h, 12h, 18h, 24h

# This function retrieves the modules for which the algorithm gave output at every timepoint (i.e. for which PCA was calculated at each timepoint), for the condition of interest. It updates the module and sample matrices accordingly.
run_roma_MTX_vs_Control_all_timepoints_module_matrix <- function(counts_in_vitro_df, treatment_interest, timepoint1, timepoint2, timepoint3, timepoint4, timepoint5, run_roma_MTX_vs_Control_module_matrix_all_timepoint_filename){
  
  # Run rRoma for the 1st timepoint (with condition of interest), using the hallmark gene sets.
  run_roma_MTX_vs_Control <- rRoma.R(counts_in_vitro_df %>% dplyr::select(contains(timepoint1)) %>% dplyr::select(contains(treatment_interest) | contains("Control")), hallmark_gene_sets_gmt)
  
  
  # Retrieve module matrix from roma output, convert it to df,  and put modules (i.e. rownames) in a column.
  run_roma_MTX_vs_Control_module_matrix <- run_roma_MTX_vs_Control$ModuleMatrix %>% as.data.frame() %>% rownames_to_column("modules")
  
  # Remove REACTOME_ in front of each gene set name
  run_roma_MTX_vs_Control_module_matrix$modules <- sub("REACTOME_", "", run_roma_MTX_vs_Control_module_matrix$modules)
    
    
  # Create a vector containing the subsequent timepoints
  timepoint_vect <- c(timepoint2, timepoint3, timepoint4, timepoint5)
  
  # Loop through this vector
  for (timepoint_interest in timepoint_vect){
    
    # Run rRoma for the looping timepoint, using the hallmark gene sets
    run_roma_MTX_vs_Control_timepoint_interest <- rRoma.R(counts_in_vitro_df %>% dplyr::select(contains(timepoint_interest)) %>% dplyr::select(contains(treatment_interest) | contains("Control")), hallmark_gene_sets_gmt)
    
    
    # Retrieve module matrix from roma output, convert it to df,  and put modules (i.e. rownames) in a column.
    run_roma_MTX_vs_Control_timepoint_interest_module_matrix <- run_roma_MTX_vs_Control_timepoint_interest$ModuleMatrix %>% as.data.frame() %>% rownames_to_column("modules")
    
    
    # Retrieve sample matrix from roma output, convert it to df, and put modules (i.e. rownames) in a column
    run_roma_MTX_vs_Control_timepoint_interest_sample_matrix <- run_roma_MTX_vs_Control_timepoint_interest$SampleMatrix %>% as.data.frame() %>% rownames_to_column("modules")
    
    
    # Remove REACTOME_ in front of each gene set name, in module and sample matrices
    run_roma_MTX_vs_Control_timepoint_interest_module_matrix$modules <- sub("REACTOME", "", run_roma_MTX_vs_Control_timepoint_interest_module_matrix$modules)
    
    
    run_roma_MTX_vs_Control_timepoint_interest_sample_matrix$modules <- sub("REACTOME", "", run_roma_MTX_vs_Control_timepoint_interest_module_matrix$modules)
    
    
    # Inner join of the module and sample matrices to retrieve modules for which we got output at each timepoint.
    run_roma_MTX_vs_Control_module_matrix <- inner_join(run_roma_MTX_vs_Control_module_matrix, run_roma_MTX_vs_Control_timepoint_interest_module_matrix, by="modules")
    
    
     run_roma_MTX_vs_Control_sample_matrix <- inner_join(run_roma_MTX_vs_Control_sample_matrix, run_roma_MTX_vs_Control_timepoint_interest_sample_matrix, by="modules")
     
     
     # Make sure that modules in sample matrix are in the same order than in the module matrix
     run_roma_MTX_vs_Control_sample_matrix <- run_roma_MTX_vs_Control_sample_matrix[, run_roma_MTX_vs_Control_module_matrix$modules]
     
     
     }
  
  # Save final joined module and sample matrices
  write.csv(run_roma_MTX_vs_Control_module_matrix, run_roma_MTX_vs_Control_module_matrix_all_timepoint_filename)
  write.csv(run_roma_MTX_vs_Control_sample_matrix, run_roma_MTX_vs_Control_sample_matrix_all_timepoint_filename)
}


# Get modules overdispersed at least one timepoint and update the module and sample matrices according to them.
get_modules_overdispersed_at_least_one_timepoint <- function(run_roma_MTX_vs_Control_module_matrix_all_timepoint_filename, run_roma_MTX_vs_Control_sample_matrix_all_timepoint_filename, run_roma_MTX_vs_Control_module_matrix_overdispersed_at_least_one_time_point_filename, run_roma_MTX_vs_Control_sample_matrix_overdispersed_at_least_one_time_point_filename){
  
  
  # Load the final joined module matrix 
  run_roma_MTX_vs_Control_module_matrix_all_timepoint <-  read.csv(run_roma_MTX_vs_Control_module_matrix_all_timepoint_filename)
  
  
  # Load the final joined sample matrix 
  run_roma_MTX_vs_Control_sample_matrix_all_timepoint <-  read.csv(run_roma_MTX_vs_Control_sample_matrix_all_timepoint_filename)
  
  # Loop through the the joined module matrix
  for (i in 1:nrow(run_roma_MTX_vs_Control_module_matrix_all_timepoint)){
    
    # Test if the underlying module is overdispersed at least one time point
    
    # If not
    if (run_roma_MTX_vs_Control_module_matrix_all_timepoint[i, "ppv L1.x"] > 0.05 & run_roma_MTX_vs_Control_module_matrix_all_timepoint[i, "ppv L1.y"] > 0.05 & run_roma_MTX_vs_Control_module_matrix_all_timepoint[i, "ppv L1.x.x"] > 0.05 & run_roma_MTX_vs_Control_module_matrix_all_timepoint[i, "ppv L1.y.y"] > 0.05 & run_roma_MTX_vs_Control_module_matrix_all_timepoint[i, "ppv L1"] > 0.05){
      
      # Get rid of it from module and sample matrices
      run_roma_MTX_vs_Control_module_matrix_all_timepoint <- run_roma_MTX_vs_Control_module_matrix_all_timepoint %>% dplyr::slice(-i)

      run_roma_MTX_vs_Control_sample_matrix_all_timepoint <- run_roma_MTX_vs_Control_sample_matrix_all_timepoint %>% dplyr::slice(-i)
      }
    
  }
  
  # Save the module and sample matrices with modules overdispersed at least one timepoint
  write.csv(run_roma_MTX_vs_Control_module_matrix_all_timepoint, run_roma_MTX_vs_Control_module_matrix_overdispersed_at_least_one_time_point_filename)
  
  write.csv(run_roma_MTX_vs_Control_sample_matrix_all_timepoint, run_roma_MTX_vs_Control_sample_matrix_overdispersed_at_least_one_time_point_filename)
  
  
  
}


## Now if I want to highlight the timepoint(s) at which the modules are overdispersed

# How can I proceed ?

## Assuming that there are 3 replicates for each condition
# For a given module, at the timepoint(s) where it is not overdispersed, put its activity scores in the underlying samples at 0.
# As an example, if a module is not overdispersed between cell lines treated with MTX and those untreated (at 3h), I will not deem it as relevant and put its activity scores in the considered samples at 0.


# In this function: 

# 1. Load the module and sample matrices restricted to the modules overdispersed at least one timepoint
# 2. Assign the value of 0 to the activity scores of the modules that are not overdispersed at a certain timepoint.

put_activity_scores_not_overdispersed_at_0 <- function(run_roma_MTX_vs_Control_module_matrix_overdispersed_at_least_one_time_point_filename, run_roma_MTX_vs_Control_sample_matrix_overdispersed_at_least_one_time_point_filename, run_roma_MTX_vs_Control_sample_matrix_overdispersed_at_least_one_time_point_for_visualization_filename){
  
  
  # Load module matrix with modules overdispersed at least one timepoint
  run_roma_MTX_vs_Control_module_matrix_overdispersed_at_least_one_time_point <- read.csv(run_roma_MTX_vs_Control_module_matrix_overdispersed_at_least_one_time_point_filename)
  
  
  # Load sample matrix with modules overdispersed at least one timepoint
  run_roma_MTX_vs_Control_sample_matrix_overdispersed_at_least_one_time_point <- read.csv(run_roma_MTX_vs_Control_sample_matrix_overdispersed_at_least_one_time_point_filename) 
  
  
  # Get the timepoints at which there is no overdispersion, and put the corresponding activity scores at 0
  for (i in 1:nrow(run_roma_MTX_vs_Control_module_matrix_overdispersed_at_least_one_time_point)){
    
    
    # Check if the module is not overdispersed at first timepoint
    if (run_roma_MTX_vs_Control_module_matrix_overdispersed_at_least_one_time_point[i, "ppv L1.x"] > 0.05){
      
      # If yes, put activity scores of the module in treated and untreated samples, at the first timepoint, at 0
      run_roma_MTX_vs_Control_sample_matrix_overdispersed_at_least_one_time_point[i, 2:7] <- 0
      
    }
    
    
    # Check if the module is not overdispersed at second timepoint
    if (run_roma_MTX_vs_Control_module_matrix_overdispersed_at_least_one_time_point[i, "ppv L1.y"] > 0.05){
      
      # If yes, put activity scores of the module in treated and untreated samples, at the second timepoint, at 0
      run_roma_MTX_vs_Control_sample_matrix_overdispersed_at_least_one_time_point[i, 8:13] <- 0
      
    }
    
    
    
    # Check if the module is not overdispersed at third timepoint
    if (run_roma_MTX_vs_Control_sample_matrix_overdispersed_at_least_one_time_point[i, "ppv L1.x.x"] > 0.05){
      
      # If yes, put activity scores of the module in treated and untreated samples, at the third timepoint, at 0
      run_roma_MTX_vs_Control_sample_matrix_overdispersed_at_least_one_time_point[i, 14:19] <- 0
      
    }
    
    
    # Check if the module is not overdispersed at fourth timepoint
    if (run_roma_MTX_vs_Control_module_matrix_overdispersed_at_least_one_time_point[i, "ppv L1.y.y"] > 0.05){
      
      # If yes, put activity scores of the module in treated and untreated samples, at the fourth timepoint, at 0
      run_roma_MTX_vs_Control_sample_matrix_overdispersed_at_least_one_time_point[i, 20:25] <- 0
      
    }
    
    
    # Check if the module is not overdispersed at fifth timepoint
    if (run_roma_MTX_vs_Control_module_matrix_overdispersed_at_least_one_time_point[i, "ppv L1"] > 0.05){
      
      # If yes, put activity scores of the module in treated and untreated samples, at the fifth timepoint, at 0
      run_roma_MTX_vs_Control_sample_matrix_overdispersed_at_least_one_time_point[i, 26:31] <- 0
      
    }
  }
  # Save updated sample matrix (i.e. with activity scores at 0 for modules not overdispersed at a certain timepoint)
  write.csv(run_roma_MTX_vs_Control_sample_matrix_overdispersed_at_least_one_time_point, run_roma_MTX_vs_Control_sample_matrix_overdispersed_at_least_one_time_point_for_visualization_filename)
  
}



# Now if I want to visualize the activity scores of the modules overdispersed at least one timepoint (i.e. with 0 for timepoints where there is no overdispersion)



# Load sample matrix for modules overdispersed at least one timepoint (with 0 for non-overdispersion)
run_roma_MTX_vs_Control_sample_matrix_overdispersed_at_least_one_time_point_for_visualization <- read.csv(run_roma_MTX_vs_Control_sample_matrix_overdispersed_at_least_one_time_point_for_visualization_filename) 



# Remove control samples from the sample matrix
run_roma_MTX_vs_Control_sample_matrix_overdispersed_at_least_one_time_point_for_visualization_no_control <- run_roma_MTX_vs_Control_sample_matrix_overdispersed_at_least_one_time_point_for_visualization %>% as.data.frame() %>% dplyr::select(!contains("Control")) %>% as.matrix()


# Create annotation for the sample matrix
chimio <- "MTX"
time <- c("3h", "6h", "12h", "18h", "24h")
annot_col <- data.frame(Time = rep(time, each=3), Treatment = rep(chimio, times = 15))
rownames(annot_col) <- colnames(run_roma_MTX_vs_Control_sample_matrix_overdispersed_at_least_one_time_point_for_visualization_no_control)


# Create pheatmap for visualization (if you need to restrict those reactome pathways to only few of those, you just need to subset from the sample matrix)
pheatmap::pheatmap(run_roma_MTX_vs_Control_sample_matrix_overdispersed_at_least_one_time_point_for_visualization_no_control, cluster_rows = TRUE, cluster_cols = FALSE, fontsize_row = 11, fontsize_col = 11,  main="Reactome pathways overdispersed at least one timepoint", annotation_col = annot_col, sep="_", color=colorRamps::blue2red(20), show_colnames = FALSE, gp=gpar(fontsize=10))




# decoupleR: a package, containing different statistical methods that coupled with prior knowledge resources, estimates biological activities from omics data. It can be used for pathway activity inference, but as well to estimate the activity of TF and kinases.
# In the case of pathways, decoupleR contains a comprehensive resource containing a curated collection 14 of pathways and their target genes, with weights for each interaction, called PROGENy.

# So once I imported the PROGEny model from decoupleR, I want to investigate the activity of the 14 pathways in the treated cell lines.

# How do I proceed ?


# Function that retrieves the activity of the 14 pathways from PROGENy
get_pathways_activity_PROGENy <- function(timepoint_1, timepoint_2, timepoint_3, timepoint_4, timepoint_5, 
                                          drug, pathway_activity_drug_timepoint_df_filename){
  
  
  # Retrieve PROGENy collection of pathways (with top 500 responsive genes)
  net <- decoupleR::get_progeny(organism = "mouse", top = 500)
  
  
    
  # First timepoint
  
  
  # Load t-values (with gene names) of the DEGs between treated and untreated cell lines at first timepoint
  t_values_DEGs_drug_vs_control_timepoint_1 <- read.csv(paste0("all_diff_genes_",drug,"_",timepoint_1, "_vs_","Control_",timepoint_1,".csv")) %>% dplyr::select(c("t","gene_name"))
  
  # Put gene names as rownames
  rownames(t_values_DEGs_drug_vs_control_timepoint_1) <- make.names(t_values_DEGs_drug_vs_control_timepoint_1$gene_name, unique=TRUE)
    
  # Remove gene name column
  t_values_DEGs_drug_vs_control_timepoint_1 <- t_values_DEGs_drug_vs_control_timepoint_1 %>% dplyr::select(-"gene_name")
    
  # Run decoupleR on treated vs control cell lines at timepoint_1
  run_decoupler_drug_timepoint_1 <- decoupleR::decouple(mat = t_values_DEGs_drug_vs_control_timepoint_1, net = net, .source = "source", .target = "target", consensus_score = FALSE)
  
  # Get consensus score between methods from the decouple function
  run_decoupler_drug_timepoint_1_consensus <- decoupleR::run_consensus(run_decoupler_drug_timepoint_1, seed = 2)
  
  # Transform to wide matrix
  run_decoupler_drug_timepoint_1_consensus_pivot <- run_decoupler_drug_timepoint_1_consensus %>% 
      pivot_wider(id_cols = 'condition', names_from = 'source', values_from = 'score') %>% 
      column_to_rownames('condition') %>%
      as.matrix()
  
  
  # Get the transpose, put pathway name as column, and rename the column containing activity scores as drug_timepoint
  pathway_activity_drug_timepoint_df <- t(run_decoupler_drug_timepoint_1_consensus_pivot) %>% as.data.frame() %>% rownames_to_column("pathway") %>% dplyr::rename(paste0(drug,"_",timepoint_1) = "t")
  
  
  # Subsequent timepoints
    
  # Create a vector containing the subsequent timepoints
  timepoint_vect <- c(timepoint2, timepoint3, timepoint4, timepoint5)
  
  # Loop through this vector
  for (timepoint_interest in timepoint_vect){
    
    
    # Load t-values of the DEGs between treated and control cell lines at timepoint of interest
    t_values_DEGs_drug_vs_control_timepoint_interest <- read.csv(paste0("all_diff_genes_",drug,"_",timepoint_interest, "_vs_","Control_",timepoint_interest,".csv"))
    
    
    # Put gene names as rownames
    rownames(t_values_DEGs_drug_vs_control_timepoint_interest) <- make.names(t_values_DEGs_drug_vs_control_timepoint_interest$gene_name, unique=TRUE)
    
    
      
    # Remove gene name column
    t_values_DEGs_drug_vs_control_timepoint_interest <- t_values_DEGs_drug_vs_control_timepoint_interest %>% dplyr::select(-"gene_name")
    
    
    # Run decoupleR on treated vs control cell lines at timepoint_interest
    run_decoupler_drug_timepoint_interest <- decoupleR::decouple(mat = t_values_diff_genes_drug_vs_control_timepoint_interest, net = net, .source = "source", .target = "target", consensus_score = FALSE)
    
    # Get consensus score between methods from the decouple function
    run_decoupler_drug_timepoint_interest_consensus <- decoupleR::run_consensus(run_decoupler_drug_timepoint_interest, seed = 2)
    
    
    # Transform to wide matrix 
    run_decoupler_drug_timepoint_consensus_pivot <- run_decoupler_drug_timepoint_interest_consensus %>% 
        pivot_wider(id_cols = 'condition', names_from = 'source', values_from = 'score') %>%
        column_to_rownames('condition') %>%
        as.matrix()
    
    
    # Get the transpose, and put pathway name as column
    pathway_activity_drug_timepoint_interest_df <- t(run_decoupler_drug_timepoint_interest_consensus_pivot) %>% as.data.frame() %>% rownames_to_column("pathway") %>% dplyr::rename(paste0(drug,"_",timepoint_interest) = "t")
    
    
    # Inner join of the pathway activity scores across the five timepoints (i.e. the five conditions) + scaling across timepoints
    pathway_activity_drug_timepoint_df <- inner_join(pathway_activity_drug_timepoint_df, pathway_activity_drug_timepoint_interest_df, by="pathway") %>% column_to_rownames("pathway") %>% t() %>% scale() %>% t()
    
  }
  # Scale the activity scores across the 5 timepoints (+ save final df)
  pathway_activity_drug_timepoint_df <- pathway_activity_drug_timepoint_df %>% column_to_rownames("pathway") %>% t() %>% scale() %>% t() 
  write.csv(pathway_activity_drug_timepoint_df, pathway_activity_drug_timepoint_df_filename, row.names = TRUE)
}


# So if now I want to retrieve the activity scores of the 14 pathways in cell lines treated with a specific drug (such as Mitoxantrone) relative to control cell lines.

# How do I proceed ?


# Just call the above function (with MTX as an example)
get_pathways_activity_PROGENy("3h", "6h", "12h", "18h", "24h", "MTX", "PROGENy_activity_MTX_all_timepoints.csv")


  
# Now if want to retrieve the activity scores of the 14 pathways across all the drugs (here MTX, OXA, and CIS) and timepoints, and plot them.


# How can I proceed ?


# Load df containing PROGENy pathway activities in MTX-treated vs control cell lines
pathways_activity_PROGENy_MTX <- read.csv("PROGENy_activity_MTX_all_timepoints.csv")

# Load df containing PROGENy pathway activities in OXA-treate vs control cell lines
get_pathways_activity_PROGENy("3h", "6h", "12h", "18h", "24h", "MTX", "PROGENy_activity_OXA_all_timepoints.csv")
pathways_activity_PROGENy_OXA <- read.csv("PROGENy_activity_OXA_all_timepoints.csv")

# Load df containing PROGENy pathway activities in CIS-treated vs control cell lines
get_pathways_activity_PROGENy("3h", "6h", "12h", "18h", "24h", "MTX", "PROGENy_activity_CIS_all_timepoints.csv")
pathways_activity_PROGENy_CIS <- read.csv("PROGENy_activity_CIS_all_timepoints.csv")


# Inner join of the pathway activity scores across all three drugs (+ save it)
pathway_activity_PROGENy_MTX_OXA <- inner_join(pathways_activity_PROGENy_MTX, pathways_activity_PROGENy_OXA, by="pathway")
pathway_activity_PROGENy_all_three_drugs <- inner_join(pathway_activity_PROGENy_MTX_OXA, pathway_activity_PROGENy_CIS, by="pathway")

# The user is free to specify the filename
write.csv(pathway_activity_PROGENy_all_three_drugs, pathway_activity_PROGENy_all_three_drugs_filename, row.names=TRUE, col.names=TRUE)


# Plot these activity scores

# Set palette length
palette_length <- 100 

# Use the viridis color palette
my_color <- viridis::viridis(palette_length)

# Create column annotation
annotation_columns_treatment <- data.frame(treatment = rep(c("MTX","OXA","CIS"),c(5,5,5)))
rownames(annotation_columns_treatment)[1:5] <- colnames(pathway_activity_PROGENy_all_three_drugs)[1:5]
rownames(annotation_columns_treatment)[6:10] <- colnames(pathway_activity_PROGENy_all_three_drugs)[6:10]
rownames(annotation_columns_treatment)[11:15] <- colnames(pathway_activity_PROGENy_all_three_drugs)[11:15]


# Set color for column annotation
annot_colors_all <- list(treatment=c(MTX="royalblue", OXA="firebrick", CIS = "forestgreen"))


# Create heatmap for visualization
pathway_activity_progeny_heatmap_t_values <- ComplexHeatmap::pheatmap(as.matrix(pathway_activity_PROGENy_all_three_drugs), color = my_color, annotation_col = annotation_columns_treatment, annotation_colors = annot_colors_all, fontsize_row = 11.5, fontsize_col = 11.5, cluster_rows = TRUE, cluster_cols = TRUE, main="Pathway activity (PROGENy) in all the conditions - t-values", fontface = 3, show_colnames = TRUE, heatmap_legend_param = list(title = "activity_score", title_gp = gpar(fontsize = 10, fontface="bold"), title_position= "topcenter",legend_height = grid::unit(35,"mm"), grid_width = grid::unit(5,"mm"), labels_gp = gpar(col = "black", font = 2), legend_direction = "horizontal", legend_width = unit(5,"cm")), border_color = "white") %>% ComplexHeatmap::draw(heatmap_legend_side = "bottom", annotation_legend_side = "right")


# If now I want to retrieve the info about the targets


# Retrieve PROGENy collection of pathways (with top 500 responsive genes)
net <- decoupleR::get_progeny(organism = "mouse", top = 500)

# Call a gene with a positive weight as an "activator" and a gene with a negative weight as an "inhibitor".
net_for_targets <- net %>% mutate(target_type = if_else(weight > 0, "activator","inhibitor"))


# Create a function that retrieves the target info for the activity scores of each of the 14 pathways.
get_target_info_14_progeny_pathways <- function(t_values_diff_genes_filename, pathway_activity_PROGENy_all_three_drugs_filename){
  
  # Load t-values of the DEGs between MTX-treated vs control cell lines at 24h
  t_values_diff_genes_interest <- read.csv(t_values_diff_genes_filename) %>% select(c("t","gene_name"))
  
  # Put gene names as rownames
  rownames(t_values_diff_genes_interest) <- make.names(t_values_diff_genes_interest$gene_name, unique=TRUE)
  
  # Put the rownames back into column, named as target
  t_values_diff_genes_interest <- t_values_diff_genes_interest %>% dplyr::select(-"gene_name") %>% rownames_to_column("target")
  
  
  # Load activity scores of the 14 progeny pathways
  pathway_activity_PROGENy_all_three_drugs <- read.csv(pathway_activity_PROGENy_all_three_drugs_filename)
  
  
  # Loop through each of the 14 progeny pathways
  for (i in 1:nrow(pathway_activity_PROGENy_all_three_drugs)){
    
    # Retrieve info of the differentially expressed targets used to calculate the activity score of the underlying pathway (i.e. weight, p-value, target_type, t-value)
    pathway_activity_progeny <- net_for_targets %>% filter(source == rownames(pathway_activity_PROGENy_all_three_drugs)[i]) %>% inner_join(.,t_values_diff_genes_interest, by="target")
    
    # Arrange the differentially expressed targets in decreasing order (based on their amount of up/down regulation)
    pathway_activity_progeny_arranged <- pathway_activity_progeny %>% dplyr::arrange(desc(abs(t)))
    
    
    # Save the arranged target info in a csv file
    write.csv(pathway_activity_progeny_arranged, paste0(rownames(pathway_progeny_results_t_values)[i],"_targets_all_info.csv"), col.names = TRUE, row.names = FALSE)
    
  }
  
}


# As an example, I want to retrieve target info for the activity scores of the 14 pathways in MTX-treated vs control cell lines at 24h
# Just need to call the above function, with filename for t-values of the DEGs between MTX-treated and control cell lines at 24h, as well as the filename for the df containing the activity scores of the 14 PROGENy pathways across all the conditions.
get_target_info_14_progeny_pathways(t_values_diff_genes_filename, pathway_activity_PROGENy_all_three_drugs_filename)


```



# **5. Transcription factor activity inference**
  

  
```{r eval=FALSE, echo=TRUE}

# First, I want to run the rRoma algorithm to infer the activity of transcription factors, where each TF contains a set of targets.


# How do I proceed ?
# Import the regulatory gene sets from GTRD (gmt file).
tf_gmt <- ReadGMTFile("/data/users/tlassale/MODICED_link/Bulk_RNA_in_vitro/in_vitro_results/m3.gtrd.v2023.2.Mm.symbols.gmt")


# Launch rRoma
# As en example, I decided to quantify activity of hallmark gene sets over MTX-treated vs untreated cell lines (at 24h)
# Inputs of the rRoma.R function:
# 1) Normalised count matrix (here I used cpm from edgeR for normalisation)
# 2) gmt file (here I extracted hallmark gene sets from MSigDB)
run_roma_tf_MTX_vs_Control_24h <- rRoma.R(counts_in_vitro_df %>% dplyr::select(contains("24h")) %>% dplyr::select(contains("MTX") | contains("Control")), tf_gmt)

# Save roma ouptut
filename <- "..."
saveRDS(run_roma_tf_MTX_vs_Control_24h, filename)


# Now, I want to retrieve TFs with interesting activities, that is those which are shifted and overdispersed.
  

# Get shifted TFs (here focus on GTRD gene sets)
# What does this function perform ?
# 1) Retrieve shifted TFs and store them (arranged by the p-value associated to the shift)
# 2) Get top 50 contributing targets for the activity scores of the shifted TFs.
# 3) Plot (+save) the activity scores of the top 20 shifted TFs (arranged by p-value), using roma-based function and ComplexHeatmap package.



get_shifted_tfs <- function(roma_output_filename, shifted_tfs_matrix_filename, shifted_tfs_matrix_top_20_filename, top_20_shifted_tfs_roma_heatmap_filename, top_20_shifted_tfs_complex_heatmap_filename){
  
  # Load roma output
  roma_output <- readRDS(roma_output_filename)
  
  # Remove (from module matrix) HALLMARK prefix in front of each gene set name
  rownames(roma_output$ModuleMatrix) <- gsub("_TARGET_GENES","", rownames(roma_output$ModuleMatrix))
  rownames(roma_output$SampleMatrix) <- gsub("_TARGET_GENES","" ,rownames(roma_output$SampleMatrix))
  
  # Get the index of the shifted tfs in the module matrix (for plotting)
  shifted_tfs_index <- which(roma_output$ModuleMatrix[,"ppv Median Exp"] <= 0.05)
  
  
  # Restrict the module matrix to the shifted tfs and sort them by their p-value (+ save)
  shifted_tfs_matrix <- roma_output$ModuleMatrix %>% as.data.frame() %>% dplyr::filter(`ppv Median Exp`<= 0.05) %>% dplyr::arrange(`ppv Median Exp`) %>% rownames_to_column("shifted_tfs")
  write.csv(shifted_tfs_matrix, shifted_tfs_matrix_filename)
  
  
  
  # Get top contributing genes of shifted TFs + Save them
  # I retrieve top 50 here (but you are free to retrieve more)
  
  
  # Loop through the module matrix restricted to the shifted tfs
  for (i in 1:nrow(shifted_tfs_matrix)){
    
     # Get top 50 contributing genes for the activity scores of the underlying shifted module (sorted decreasingly by their weight)
    tf_targets_all_info <- GetTopContrib(get_roma_results, Selected = which(rownames(roma_output$ModuleMatrix) == shifted_tfs_matrix$shifted_tfs[i]), nGenes = 50, OrderType = "Abs", Mode = "Wei", Plot = TRUE)$Table %>% dplyr::select(c("Gene","Weight")) %>% as.data.frame() %>% dplyr::arrange(desc(abs(Weight)))
   
    
    # Remove rownames
    rownames(tf_targets_all_info) <- NULL
    
    # Save top 50 contributing genes matrix
    write.csv(tf_targets_all_info, paste0(top_contributing_genes_filename, rownames(shifted_tfs_sample_matrix)[i],"_contributing_genes_activity_score.csv"), col.names = TRUE, row.names = FALSE)
  }
  
  # Retrieve top 20 shifted tfs + Save them
  shifted_tfs_matrix_top_20 <- shifted_tfs_matrix %>% dplyr::slice(1:20)
  write.csv(shifted_tfs_matrix_top_20, shifted_tfs_matrix_top_20_filename)
  
  # Plot activity scores of top 20 shifted tfs
  # using the Plot.Genesets.Samples() function from roma
  png(top_20_shifted_tfs_roma_heatmap_filename, width=1000, height=502)
  Plot.Genesets.Samples(roma_output, Selected = shifted_tfs_index[shifted_tfs_matrix_top_20$shifted_tfs], cluster_cols = TRUE)
  dev.off()
  
  
  
  
  # using ComplexHeatmap package to make a customized heatmap.
  palette_length <- 100
  my_color <- viridis::viridis(palette_length)
  
  # Retrieve activity scores of top 20 shifted tfs
  shifted_tfs_sample_matrix <- roma_output$SampleMatrix %>% filter(rownames(.) %in% shifted_tfs_matrix$shifted_tfs)
  shifted_tfs_sample_matrix_top_20_arranged <- shifted_tfs_sample_matrix[shifted_tfs_matrix_top_20,]
  
  # Plot and save them
  png(top_20_shifted_tfs_complex_heatmap_filename, width=1000, height=502)
  heatmap_top_20_shifted_tfs <- ComplexHeatmap::pheatmap(as.matrix(shifted_tfs_sample_matrix_top_20_arranged), color= my_color,cluster_rows = TRUE, cluster_cols = TRUE, fontsize_row = 11, fontsize_col = 11,  main="Top 20 shifted tfs", fontface = 3, show_colnames = TRUE, heatmap_legend_param = list(title = "activity_score", title_gp = gpar(fontsize = 10, fontface="bold"), title_position= "topcenter",legend_height = grid::unit(35,"mm"), grid_width = grid::unit(5,"mm"), labels_gp = gpar(col = "black", font = 2), legend_direction = "horizontal", legend_width = unit(5,"cm")), cellwidth = 20) %>% ComplexHeatmap::draw(heatmap_legend_side = "bottom", annotation_legend_side = "right")
  dev.off()
}



# Get overdispersed TFs (here focus on GTRD gene sets)
# What does this function perform ?
# 1) Retrieve the module and samples matrices associated with overdispersed TFs and store them (arranged by the p-value associated to the shift)
# 2) Get top 50 contributing targets for the activity scores of the overdispersed TFs.
# 3) Plot (+save) the activity scores of the top 20 overdispersed TFs (arranged by p-value), using roma-based function and ComplexHeatmap package.


get_overdispersed_tfs <- function(roma_output_filename, overdispersed_tfs_matrix_filename, overdispersed_tfs_sample_matrix_filename, overdispersed_tfs_matrix_top_20_filename, top_20_overdispersed_tfs_roma_heatmap_filename, top_20_overdispersed_tfs_complex_heatmap_filename){
  
  # Load roma output
  roma_output <- readRDS(roma_output_filename)
  
  # Remove (from module matrix) HALLMARK prefix in front of each gene set name
  rownames(roma_output$ModuleMatrix) <- gsub("_TARGET_GENES","", rownames(roma_output$ModuleMatrix))
  rownames(roma_output$SampleMatrix) <- gsub("_TARGET_GENES","" ,rownames(roma_output$SampleMatrix))
  
  # Get the index of the overdispersed tfs in the module matrix (for plotting)
  overdispersed_tfs_index <- which(roma_output$ModuleMatrix[,"ppv Median Exp"] <= 0.05)
  
  
  # Restrict the module matrix to the overdispersed tfs and sort them by their p-value (+ save)
  overdispersed_tfs_module_matrix <- roma_output$ModuleMatrix %>% as.data.frame() %>% dplyr::filter(`ppv L1`<= 0.05 & `ppv Median Exp` > 0.05) %>% dplyr::arrange(`ppv L1`) %>% rownames_to_column("overdispersed_tfs")
  write.csv(overdispersed_tfs_matrix, overdispersed_tfs_matrix_filename)
  
  
  # Restrict the sample matrix to the overdispersed tfs
  overdispersed_tfs_sample_matrix <- roma_output$SampleMatrix[overdispersed_tfs_module_matrix$overdispersed_tfs,] %>% rownames_to_column("overdispersed_tfs")
  write.csv(overdispersed_tfs_sample_matrix, overdispersed_tfs_sample_matrix_filename)
  
  # Get top contributing genes of overdispersed TFs + Save them
  # I retrieve top 50 genes here (but you are free to retrieve more)
  
  
  # Loop through the module matrix restricted to the overdispersed tfs
  for (i in 1:nrow(overdispersed_tfs_matrix)){
    
     # Get top 50 contributing genes for the activity scores of the underlying overdispersed module (sorted decreasingly by their weight)
    tf_targets_all_info <- GetTopContrib(get_roma_results, Selected = which(rownames(roma_output$ModuleMatrix) == overdispersed_tfs_matrix$overdispersed_tfs[i]), nGenes = 50, OrderType = "Abs", Mode = "Wei", Plot = TRUE)$Table %>% dplyr::select(c("Gene","Weight")) %>% as.data.frame() %>% dplyr::arrange(desc(abs(Weight)))
   
    
    # Remove rownames
    rownames(tf_targets_all_info) <- NULL
    
    # Save top 50 contributing genes matrix
    write.csv(tf_targets_all_info, paste0(top_contributing_genes_filename, rownames(overdispersed_tfs_sample_matrix)[i],"_contributing_genes_activity_score.csv"), col.names = TRUE, row.names = FALSE)
  }
  
  # Plot activity scores of top 20 overdispersed tfs
  # using the Plot.Genesets.Samples() function from roma
  overdispersed_tfs_matrix_top_20 <- overdispersed_tfs_matrix %>% dplyr::slice(1:20)
  png(top_20_overdispersed_tfs_roma_heatmap_filename, width=1000, height=502)
  Plot.Genesets.Samples(roma_output, Selected = overdispersed_tfs_index[overdispersed_tfs_matrix_top_20$overdispersed_tfs], cluster_cols = TRUE)
  dev.off()
  

  
  
  
  
  # using ComplexHeatmap package to make a customized heatmap.
  palette_length <- 100
  my_color <- viridis::viridis(palette_length)
  
  # Retrieve activity scores of top 20 overdispersed tfs
  overdispersed_tfs_sample_matrix <- roma_output$SampleMatrix %>% filter(rownames(.) %in% overdispersed_tfs_matrix$overdispersed_tfs)
  overdispersed_tfs_sample_matrix_top_20_arranged <- overdispersed_tfs_sample_matrix[overdispersed_tfs_matrix_top_20,]
  
  # Plot and save them
  png(top_20_overdispersed_tfs_complex_heatmap_filename, width=1000, height=502)
  heatmap_top_20_overdispersed_tfs <- ComplexHeatmap::pheatmap(as.matrix(overdispersed_tfs_sample_matrix_top_20_arranged), color= my_color,cluster_rows = TRUE, cluster_cols = TRUE, fontsize_row = 11, fontsize_col = 11,  main="Top 20 overdispersed tfs", fontface = 3, show_colnames = TRUE, heatmap_legend_param = list(title = "activity_score", title_gp = gpar(fontsize = 10, fontface="bold"), title_position= "topcenter",legend_height = grid::unit(35,"mm"), grid_width = grid::unit(5,"mm"), labels_gp = gpar(col = "black", font = 2), legend_direction = "horizontal", legend_width = unit(5,"cm")), cellwidth = 20) %>% ComplexHeatmap::draw(heatmap_legend_side = "bottom", annotation_legend_side = "right")
  dev.off()
}


# Now if you spotted, in the activity scores of your overdispersed (or shifted) TFs, some TFs with an interesting activity in a given drug over time, and you want to determine if their expression has a similar trend over their observed activity.

## How can I proceed ?

# Through this example, I will show you how you can generate side-by-side plots showing the activity vs expression of any TFs you want, provided that you can retrieve both their activity (using decoupleR or rRoma algorithm) AND expression.


# In the context of the MODICED project, we aimed to characterize the effect of ICD-inducers on cancer cells, at the transcription factor level (i.e. downstream of signaling pathways). To that end, I used two different tools: 
# 1st tool: the algorithm rROMA (R implementation of ROMA) which computes the activity of a TF (TF with its targets = gene set) by calculating the first principal component of the expression matrix restricted to the genes in the gene set.
# 2nd tool: the package decoupleR which contains different statistical methods, coupled with prior knowledge databases, to extract TF activity from omics data. 



# 1st approach: you ran rRoma, using your normalized gene expression matrix, and gene sets that you retrieved from MSigDB (such as those from GTRD), you then saved the output (using the saveRDS function).


# If you need the command to run the rROMA algorithm, you can use the code below:

# Import the regulatory gene sets from GTRD (gmt file), that you can retrieve from MSigDB
# regulatory_gene_sets_filename <- "...gmt"
tf_gmt <- ReadGMTFile(regulatory_gene_sets_filename)


# To launch rRoma, you need 2 inputs:
# 1) a gene expression df, normalized with the method of your choice
# 2) the gmt file containing all the regulatory gene sets
run_roma_all_samples <- rRoma.R(gene_expression_df, tf_gmt)

# Save roma output as a rds file
filename <- "...rds"
saveRDS(run_roma_all_samples, filename)



# Now that you successfully ran the algorithm, you are able to retrieve the activity scores of your tested TFs, in your sample matrix.
# One thing to do just after you loaded your roma results, is to ensure that the TF names in the sample matrix (i.e. rownames) start with a capital letter, then the rest is in lower case.
# As an example, if you decide to test the TFs from GTRD (retrieved from MSigDB), you will need to remove "_target_genes" after each TF name, where each TF is in full capital letter, as follows:
roma_results <- readRDS(filename)
rownames(roma_results$SampleMatrix) <- rownames(roma_results$SampleMatrix) %>% str_to_title() %>% gsub("_target_genes","",.)
# In any case, whatever set of TFs you want to test, your TFs as rownames of your sample matrix, need to be in the following format: ONLY the first letter in upper case, AND no other character than the TF name.



# 2nd scenario: you used the decoupleR package, to infer transcription factor activity in your samples. 
# To run decoupleR methods, you need:
# 1. An input prior knowledge network, typically, you import from decoupleR the GRN CollecTRI, available for 3 species: human, mouse, rat.
# 2. An input gene expression matrix, that needs to be normalized (with the method of your choice)


# You can use the code below to generate a consensus activity score in each of your samples, that is to say a score between the top performer statistical methods from decoupleR.

# Get CollecTRI with all the tfs
# organism_interest <- "..." (can be human, mouse, or rat)
collectri_df <- get_collectri(organism = organism_interest, split_complexes = FALSE) %>% as.data.frame()



# Run decouple function, and use the results of the decouple function, as input of the run_consensus method
run_decoupler_all_samples <- decoupleR::decouple(mat = as.matrix(gene_expression_df) , net = collectri_df, .source = "source", .target = "target", consensus_score = FALSE)
run_decoupler_all_samples_consensus <- decoupleR::run_consensus(run_decoupler_all_samples, seed = 2)


# Transform to wide matrix (scale by TF)
run_decoupler_all_samples_consensus_pivot <- run_decoupler_all_samples_consensus %>%
  pivot_wider(id_cols = 'condition', names_from = 'source',
              values_from = 'score') %>%
  column_to_rownames('condition') %>% as.matrix() %>% scale() 


# Transpose the matrix (+ save it as a csv file), to get TFs as rows and samples as columns, where each TF is in lower case except the first character
decoupleR_final_results_matrix <- t(run_decoupler_all_samples_consensus_pivot)
# decoupleR_final_results_matrix_filename <- "...csv"
write.csv(decoupleR_final_results_matrix, decoupleR_final_results_matrix_filename, row.names = TRUE, col.names = TRUE)



# Whatever tool you used, rROMA or decoupleR, you end up with a matrix which contains the the activity scores of your tested TFs

# And, you are ready now to explore the activity vs expression of your TFs.

# You have 2 options for that:

# 1st option: In your results, you spotted some TFs with an interesting activity over time in samples treated with a specific drug, and you want to examine their expression in these same samples, to infer a potential correlation between their activity and expression. 
# 2nd option: Among the TFs you decided to test, such as those from GTRD (with roma) or those from CollecTRI (with decoupleR), you are only interested in specific TFs, for which I want to examine the activity vs expression, over time, in samples treated with a specific drug. 


# In any option you decided to use, you will need to call the 3 following functions I created below, to obtain the TF activity vs expression plots, you are looking for.


# Create a function to retrieve, among your TFs of interest, those for which I can retrieve both the activity scores and expression values
get_tfs_interest_activity_expression <- function(tf_results_matrix, gene_expression_df, TF_vector){
  
  
  # Get activity scores of the TFs of interest
  activity_tfs_interest <- tf_results_matrix %>% as.data.frame() %>% filter(rownames(.) %in% TF_vector) 
  
  # Get expression values of the TFs of interest
  expression_tfs_interest <- gene_expression_df %>% filter(rownames(.) %in% TF_vector) 
  
  # Get the vector of TFs for which we can retrieve both their activity and expression
  activity_expression_tfs_interest <- intersect(rownames(activity_tfs_interest), rownames(expression_tfs_interest))
  
  # Return the vector as the output of the function
  return(activity_expression_tfs_interest)
}



# Create a function which retrieves the mean expression and activity of the TFs from the vector, over time, in the samples treated with the drug of interest.
get_longitudinal_mean_expression_activity_tfs_drug_interest <- function(tf_results_matrix, gene_expression_df, TF_vector, timepoint_vector, drug_interest, time_info){
  
  
  # Call function defined above to retrieve the vector of TFs for which I retrieve both activity and expression  
  tfs_interest_activity_expression <- get_tfs_interest_activity_expression(tf_results_matrix, gene_expression_df, TF_vector)
  
  
  # Restrict sample matrix and gene expression df to this vector of TFs, and put it in the same order in both the matrix and df
  activity_scores_tfs_interest_df <- tf_results_matrix[tfs_interest_activity_expression,] %>% as.data.frame()
  expression_values_tfs_interest_df <- gene_expression_df[tfs_interest_activity_expression,]
  
  
  # Select, from both df columns, samples treated with the drug of interest, and order them by time (increasingly)
  activity_scores_tfs_drug_interest_df <- activity_scores_tfs_interest_df %>% dplyr::select(contains(drug_interest)) %>% dplyr::select(contains(timepoint_vector[1:length(timepoint_vector)]))
  expression_values_tfs_drug_interest_df <- expression_values_tfs_interest_df %>% dplyr::select(contains(drug_interest)) %>% dplyr::select(contains(timepoint_vector[1:length(timepoint_vector)]))
  
  
  # 1. Get the longitudinal mean expression of the TFs from the vector, in the samples treated with the drug of interest
  
  
  merged_longitudinal_mean_expression_tfs <- expression_values_tfs_drug_interest_df %>% rownames_to_column("TF") %>% gather(Sample,CPM, -TF) %>% dplyr::mutate(timepoint = sub(time_info,"",str_extract(Sample,paste0("[:digit:]+",time_info,"$")))) %>% group_by(TF,timepoint) %>% summarise(Mean_Expression=mean(CPM)) %>% as.data.frame()
  
  
  # 2. Get the longitudinal mean activity of the TFs from the vector, in the samples treated with the drug of interest
  
  
  merged_longitudinal_mean_activity_tfs <- activity_scores_tfs_drug_interest_df %>% rownames_to_column("TF") %>% gather(Sample,activity, -TF) %>% dplyr::mutate(timepoint = sub(time_info,"",str_extract(Sample,paste0("[:digit:]+",time_info,"$")))) %>% group_by(TF,timepoint) %>% summarise(Mean_Activity=mean(activity)) %>% as.data.frame()
  
  
  # Create a list with 2 elements: 
  # 1st element: expression = df storing the longitudinal mean expression of the TFs, in the samples treated with the drug of interest
  # 2nd element: activity = df storing the longitudinal mean activity of the TFs, in the samples treated with the drug of interest
  longitudinal_mean_expression_activity <- list(expression = merged_longitudinal_mean_expression_tfs, activity = merged_longitudinal_mean_activity_tfs)
  
  # Return the list as the output of the function
  return(longitudinal_mean_expression_activity)
  
}








# Plot the longitudinal mean expression vs the longitudinal mean activity score of each TF (side by side plots), in the samples treated with the drug of interest
plot_longitudinal_mean_expression_activity_drug_interest <- function(tf_results_matrix, gene_expression_df, TF_vector, timepoint_vector, drug_interest, n_timepoints, time_info){
  
  
  # Call the function defined above to retrieve the longitudinal mean expression and activity of the TFs from the vector 
  longitudinal_mean_expression_activity_tfs_drug_interest <- get_longitudinal_mean_expression_activity_tfs_drug_interest(tf_results_matrix, gene_expression_df, TF_vector, timepoint_vector, drug_interest, time_info)
  
  
  # Store the expression and activity dfs (from the above call output) into new variables
  longitudinal_mean_expression_tfs_drug_interest <- longitudinal_mean_expression_activity_tfs_drug_interest$expression
  longitudinal_mean_activity_tfs_drug_interest <- longitudinal_mean_expression_activity_tfs_drug_interest$activity
  
  
  # Create an empty list to store the plots
  list_plots <- list()
  
  # Loop through the TFs from the vector
  for (i in seq(1, nrow(longitudinal_mean_expression_tfs_drug_interest), by=n_timepoints)){
    
    # Plot longitudinal mean expression of the underlying TF
    longitudinal_mean_expression_tf_plot <- ggplot(longitudinal_mean_expression_tfs_drug_interest[i:(i+n_timepoints-1),] %>% arrange(as.numeric(timepoint)), mapping = aes(x = factor(timepoint, levels= timepoint_vector), y = Mean_Expression)) +
      geom_point(size = 2, shape=21, aes(color = TF, fill=TF)) +
      ggrepel::geom_label_repel(aes(label=TF, fill=TF), label.size = 0.15, label.padding = 0.10) +
      geom_path(aes(color=TF, group=TF), size=1.1) +
      scale_fill_brewer(palette = "Set2") +
      scale_color_brewer(palette = "Set2") +
      ggtitle(paste0("Expression of ",longitudinal_mean_expression_tfs_drug_interest[i,"TF"], " in ",drug_interest)) +
      theme_bw() +
      theme(plot.title = element_text(hjust = 0.5, face="bold", size=10)) +
      theme(axis.title = element_text(face="bold")) +
      theme(axis.text = element_text(face="bold")) +
      labs(x = "Timepoint", y = "Mean_Expression") +
      theme(legend.position = "none")
    
    
    
    # Plot longitudinal mean activity of the underlying TF
    longitudinal_mean_activity_tf_plot <- ggplot(longitudinal_mean_activity_tfs_drug_interest[i:(i+n_timepoints-1),] %>% arrange(as.numeric(timepoint)), mapping = aes(x = factor(timepoint, levels= timepoint_vector), y = Mean_Activity)) +
      geom_point(size = 2, shape=21, aes(color = TF, fill=TF)) +
      ggrepel::geom_label_repel(aes(label=TF, fill=TF), label.size = 0.15, label.padding = 0.10) +
      geom_path(aes(color=TF, group=TF), size=1.1) +
      scale_fill_brewer(palette = "Set2") +
      scale_color_brewer(palette = "Set2") +
      ggtitle(paste0("Activity of ",longitudinal_mean_activity_tfs_drug_interest[i,"TF"], " in ",drug_interest)) +
      theme_bw() +
      theme(plot.title = element_text(hjust = 0.5, face="bold", size = 10)) +
      theme(axis.title = element_text(face="bold")) +
      theme(axis.text = element_text(face="bold")) +
      labs(x = "Timepoint", y = "Mean_Activity") +
      theme(legend.position = "none")
    
    
    # Wrap plots for the longitudinal mean expression and activity of the underlying TF, into a patchwork
    longitudinal_mean_expression_activity_plots_one_by_one <- wrap_plots(longitudinal_mean_expression_tf_plot, longitudinal_mean_activity_tf_plot) & theme(plot.tag = element_text(face = "bold", size=13))
    
    # Add the patchwork for the underlying TF, in the list of plots
    list_plots <- append(list_plots, list(longitudinal_mean_expression_activity_plots_one_by_one))
    
    
  }
  
  # Return the list containing all the patchworks as the output of the function
  return(list_plots)
  
}





# If you want to add your side-by-side plots into a single patchwork, and save it as a pdf (using R):
graphics.off()
all_plots <- plot_longitudinal_mean_expression_activity_drug_interest(tf_results_matrix, gene_expression_df, TF_vector, timepoint_vector, drug_interest, n_timepoints, time_info)
all_plots_patchwork <- wrap_plots(all_plots, ncol=1)
# filename <- "...pdf"
ggsave(filename, plot = all_plots_patchwork, height = 14 , width = 7)






# How to call the different functions to retrieve, at the end, your plots of interest ?


# 1st scenario: with rROMA


# Load the sample matrix from roma_output
# roma_results_filename <- "...rds"
roma_results <- readRDS(roma_results_filename)
tf_results_matrix <- roma_results$SampleMatrix 
# Assuming that you tested the TFs from GTRD (retrieved from MSigDB)
rownames(tf_results_matrix) <- rownames(tf_results_matrix) %>% str_to_title() %>% gsub("_target_genes","",.)
# In any case, TF names (i.e. rownames of the sample matrix), need to be in the following format: only first letter in upper case, and no other character than TF name.


# Load the normalized gene expression df, used to run rROMA
# Format: genes (only first letter in upper case) as rows and samples as columns. Sample names need to contain time info, such as 3h (for hours) or 3d (for days).
# In the case, where you have samples (i.e. column names) with no timepoint, the user needs to rename those columns, by adding 0h or 0d (if as an example, you are in hours or days), in the column names
# gene_expression_df_filename <- "...csv"
gene_expression_df <- read.csv(gene_expression_df_filename, row.names = TRUE, col.names = TRUE)


# Retrieve, from the vector of TFs of interest (created just below), those for which I can retrieve both the activity scores and expression values
# TF_vector <- c("...", "...", "..."). Each element of the vector is a TF name, where only the first letter is in upper case.
get_tfs_interest_activity_expression(tf_results_matrix, gene_expression_df, TF_vector)



# Retrieve the mean expression and activity of those TFs, over time, in the samples treated with the drug of interest.
# timepoint_vector <- c("...","...","..."). Each element of the vector of the form of "3h" or "3d" (as it appears in the column names of the gene expression df)
# drug_interest <- "..."
# time_info <- "..." (for example: "h" for hours, or "d" for days)
get_longitudinal_mean_expression_activity_tfs_drug_interest(tf_results_matrix, gene_expression_df, TF_vector, timepoint_vector, drug_interest, time_info)


# Plot the longitudinal mean expression vs the longitudinal mean activity score of each of those TFs, in the samples treated with the drug of interest
# n_timepoints <- "..."
plot_longitudinal_mean_expression_activity_drug_interest(tf_results_matrix, gene_expression_df, TF_vector, timepoint_vector, drug_interest, n_timepoints, time_info)


# If you want to add your side-by-side plots into a single patchwork, and save it as a pdf (using R), it is as follows:
graphics.off()
all_plots <- plot_longitudinal_mean_expression_activity_drug_interest(tf_results_matrix, gene_expression_df, TF_vector, timepoint_vector, drug_interest, n_timepoints, time_info)
all_plots_patchwork <- wrap_plots(all_plots, ncol=1)
# filename <- "...pdf"
ggsave(filename, plot = all_plots_patchwork, height = 14 , width = 7)








# 2nd scenario: with decoupleR


# Load the results from decoupleR
# decoupleR_final_results_matrix_filename <- "...csv"
tf_results_matrix <- read.csv(decoupleR_final_results_matrix_filename, row.names = TRUE, col.names = TRUE)


# Load the normalized gene expression df, used to run rROMA
# Format: genes (only first letter in upper case) as rows and samples as columns. Sample names need to contain time info, such as 3h (for hours) or 3d (for days).
# In the case, where you have samples (i.e. column names) with no timepoint, the user needs to rename those columns, by adding 0h or 0d (if as an example, you are in hours or days), in the column names
# gene_expression_df_filename <- "...csv"
gene_expression_df <- read.csv(gene_expression_df_filename, row.names = TRUE, col.names = TRUE)


# Retrieve, from the vector of TFs of interest (created just below), those for which I can retrieve both the activity scores and expression values
# TF_vector <- c("...", "...", "..."). Each element of the vector is a TF name, where only the first letter is in upper case.
get_tfs_interest_activity_expression(tf_results_matrix, gene_expression_df, TF_vector)



# Retrieve the mean expression and activity of those TFs, over time, in the samples treated with the drug of interest.
# timepoint_vector <- c("...","...","..."). Each element of the vector of the form of "3h" or "3d" (as in the column names of the gene expression df)
# drug_interest <- "..."
# time_info <- "..." (for example: "h" for hours, or "d" for days)
get_longitudinal_mean_expression_activity_tfs_drug_interest(tf_results_matrix, gene_expression_df, TF_vector, timepoint_vector, drug_interest, time_info)


# Plot the longitudinal mean expression vs the longitudinal mean activity score of each of those TFs, in the samples treated with the drug of interest
# n_timepoints <- "..."
plot_longitudinal_mean_expression_activity_drug_interest(tf_results_matrix, gene_expression_df, TF_vector, timepoint_vector, drug_interest, n_timepoints, time_info)


# If you want to add your side-by-side plots into a single patchwork, and save it as a pdf (using R), it is as follows:
graphics.off()
all_plots <- plot_longitudinal_mean_expression_activity_drug_interest(tf_results_matrix, gene_expression_df, TF_vector, timepoint_vector, drug_interest, n_timepoints, time_info)
all_plots_patchwork <- wrap_plots(all_plots, ncol=1)
# filename <- "...pdf"
ggsave(filename, plot = all_plots_patchwork, height = 14 , width = 7)


```

















